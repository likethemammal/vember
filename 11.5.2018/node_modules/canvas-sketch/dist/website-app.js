require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({159:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/** @jsx h */
var Router = require('preact-router');

var _require = require('preact'),
    h = _require.h,
    render = _require.render;

var _require2 = require('preact-router/match'),
    Link = _require2.Link;

var Canvas = require('./components/Canvas');

var Examples = require('./components/Examples');

var gitHubUrl = 'https://github.com/mattdesl/canvas-sketch';
var gitHubUrlDocs = 'https://github.com/mattdesl/canvas-sketch/blob/master/docs/README.md';

var Navbar = function Navbar() {
  return h("div", {
    className: "top-nav"
  }, h("header", null, h(Link, {
    href: "/",
    className: "title"
  }, "canvas-sketch"), h("nav", null, h(Link, {
    activeClassName: "active",
    href: "/examples"
  }, "examples"), h("a", {
    target: "_blank",
    href: gitHubUrlDocs,
    className: "external"
  }, "docs"), h("a", {
    target: "_blank",
    href: gitHubUrl,
    className: "external"
  }, "code"))));
};

var Footer = function Footer() {
  return h("footer", null, h("div", {
    className: "rotated-brief"
  }, "a toolkit for generative art"), h("hr", {
    className: "right"
  }));
};

var Home = function Home() {
  return h("main", {
    className: "landing"
  }, h("p", null, h("strong", null, "canvas-sketch"), " is a loose collection of tools, modules, and resources for creating generative art in JavaScript and the browser."), h("p", null, "It can be used to render high-quality PNG images for Gicl\xE9e prints, create real-time web graphics (such as this page's background), export image sequences for GIF and MP4 loops, generate SVG files for pen plotters (like AxiDraw), automatically git hash your artworks for long-term archiving, and more."), h("p", null, "To get started, check out the ", h("a", {
    target: "_blank",
    href: gitHubUrlDocs
  }, "documentation"), ", or browse through ", h(Link, {
    href: "/examples"
  }, "some examples"), ", or view the ", h("a", {
    target: "_blank",
    href: gitHubUrl
  }, "source code"), " on GitHub."));
};

var Docs = function Docs() {
  return h("main", null, "Docs...");
};

var Content =
/*#__PURE__*/
function (_Router) {
  _inherits(Content, _Router);

  function Content() {
    _classCallCheck(this, Content);

    return _possibleConstructorReturn(this, _getPrototypeOf(Content).apply(this, arguments));
  }

  _createClass(Content, [{
    key: "render",
    value: function render(props, state) {
      var isHome = state.url === '/';
      return h("div", {
        className: "content-layer"
      }, h(Canvas, {
        active: isHome
      }), h(Navbar, null), _get(_getPrototypeOf(Content.prototype), "render", this).call(this, props, state), isHome && h(Footer, null));
    }
  }]);

  return Content;
}(Router);

var App = function App(props, context) {
  return h("div", {
    className: "app"
  }, h(Content, null, h(Home, {
    path: "/"
  }), h(Examples, {
    path: "/examples/:name?"
  })));
};

render(h(App, null), document.body);

},{"./components/Canvas":153,"./components/Examples":154,"preact":126,"preact-router":124,"preact-router/match":125}],154:[function(require,module,exports){
"use strict";

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/** @jsx h */
var classnames = require('classnames');

var _require = require('preact-router'),
    route = _require.route;

var _require2 = require('preact'),
    h = _require2.h,
    Component = _require2.Component;

var _require3 = require('preact-router/match'),
    Link = _require3.Link;

var _require4 = require('../data'),
    examples = _require4.examples;

var cachedSource = {};

var getSource = function getSource(name) {
  var url = "/examples/".concat(name, ".js");
  if (url in cachedSource) return cachedSource[url];
  var p = window.fetch(url).then(function (resp) {
    return resp.text();
  });
  cachedSource[url] = p;
  return p;
};

var ExampleItem = function ExampleItem(props) {
  var baseUrl = '/examples';
  var url = "".concat(baseUrl, "/").concat(props.name);
  return h("li", null, h(Link, {
    activeClassName: "active",
    href: url
  }, props.title));
};

var View =
/*#__PURE__*/
function (_Component) {
  _inherits(View, _Component);

  function View(props) {
    var _this;

    _classCallCheck(this, View);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(View).call(this, props));
    _this.state = {
      loading: false,
      code: ''
    };
    return _this;
  }

  _createClass(View, [{
    key: "loadSketch",
    value: function loadSketch(props) {
      var _this2 = this;

      var name = props.name; // If we have a name, start loading

      var loading = Boolean(name);
      this.setState({
        loading: loading,
        code: ''
      });
      getSource(name).then(function (code) {
        _this2.setState({
          loading: false,
          code: code
        });
      });
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(props, state) {
      this.loadSketch(props);
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.loadSketch(this.props);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      if (this.element && window.hljs && this.state.code && this.element.parentElement) {
        this.element.innerHTML = this.state.code;
        window.hljs.highlightBlock(this.element.parentElement);
      }
    }
  }, {
    key: "render",
    value: function render(props) {
      var _this3 = this;

      var name = props.name; // User selected an example

      if (name) {
        if (name in examples.map) {
          // Sketch exists!
          var code = this.state.code;

          if (code) {
            var sketch = examples.map[name];
            var classes = classnames('code', {
              loading: !code
            });
            return h("div", {
              className: "sketch-view"
            }, h("iframe", {
              className: "sketch",
              src: "examples/build/".concat(sketch.name, ".html"),
              width: "100%",
              height: "100%"
            }), h("div", {
              className: classes
            }, h("pre", null, h("code", {
              className: "js",
              ref: function ref(c) {
                _this3.element = c;
              }
            }))));
          } else {
            return h("div", {
              className: "sketch-view no-sketch"
            }, h("p", null, "loading"));
          }
        } else {
          // Sketch doesn't exist
          console.warn("Could not find example by id ".concat(name));
          return h("div", {
            className: "sketch-view no-sketch"
          }, h("p", null, "No sketch found by the name ", h("strong", null, name), ","), h("p", null, "try choosing a different one from the list"));
        }
      }

      return h("div", {
        className: "sketch-view no-sketch"
      }, h("p", null, "Choose a sketch from the list to begin."));
    }
  }]);

  return View;
}(Component);

module.exports = function (props, context) {
  var sections = examples.data.map(function (section) {
    if (!section.name) throw new Error('Missing "name" field in section from examples-data.json');
    var itemData = section.items || [];
    var items = itemData.filter(function (d) {
      return d.visible !== false;
    }).map(function (data) {
      return h(ExampleItem, _extends({}, data, {
        name: data.name
      }));
    });
    if (items.length === 0) return null;
    return h("ul", {
      className: "examples"
    }, h("div", {
      className: "list-section-header"
    }, section.title), items);
  }).filter(Boolean);
  var name = props.matches.name || '';
  var view = h(View, {
    name: name
  });
  return h("main", {
    className: "split-view"
  }, h("div", {
    className: "list-view"
  }, h("div", {
    className: "list-view-scroll"
  }, sections)), view);
};

},{"../data":158,"classnames":35,"preact":126,"preact-router":124,"preact-router/match":125}],158:[function(require,module,exports){
"use strict";

var getSectionData = require('./getSectionData');

var examplesData = require('./examples-data.json');

module.exports.examples = getSectionData(examplesData);

},{"./examples-data.json":156,"./getSectionData":157}],157:[function(require,module,exports){
"use strict";

module.exports = function (data) {
  var list = data.map(function (s) {
    return s.items;
  }).reduce(function (a, b) {
    return a.concat(b);
  }, []);
  var map = list.reduce(function (dict, item) {
    if (item.name in dict) throw new Error("Multiple items with the same name: ".concat(item.name));
    dict[item.name] = item;
    return dict;
  }, {});
  return {
    data: data,
    map: map,
    list: list
  };
};

},{}],156:[function(require,module,exports){
module.exports=[
  {
    "title": "Prints",
    "name": "prints",
    "items": [
      {
        "name": "canvas-10-print",
        "title": "10 PRINT"
      },
      {
        "name": "canvas-dot-flower",
        "title": "Dot Flower Business Card"
      },
      {
        "name": "canvas-generative-silhouette",
        "title": "Generative Silhouette"
      },
      {
        "name": "canvas-generative-arcs",
        "title": "Generative Arcs"
      },
      {
        "name": "canvas-abstract-risograph-print",
        "title": "Abstract Risograph Print"
      }
    ]
  },
  {
    "title": "Animated",
    "name": "animated",
    "items": [
      {
        "name": "animated-grid",
        "title": "2D Grid Animation"
      },
      {
        "name": "animated-scribble-curves",
        "title": "Scribble Curves"
      },
      {
        "name": "animated-regl-dither-blob",
        "title": "Dither Blob (WebGL/Regl)"
      },
      {
        "name": "animated-regl-fullscreen-shader",
        "title": "Fullscreen Shader (WebGL/Regl)"
      },
      {
        "name": "animated-simple-2d",
        "title": "Simple 2D Animation"
      },
      {
        "name": "animated-p5",
        "title": "Basic p5.js Integration"
      },
      {
        "name": "animated-three-basic-cube",
        "title": "Basic Three.js Integration"
      }
    ]
  },
  {
    "title": "Media",
    "name": "media",
    "items": [
      {
        "name": "canvas-image-processing",
        "title": "Image Processing"
      }
    ]
  },
  {
    "title": "Tests",
    "name": "tests",
    "items": [
      {
        "name": "canvas-pixel-processing",
        "title": "Per-Pixel Processing"
      }
    ]
  }
]

},{}],153:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/** @jsx h */
var _require = require('preact'),
    h = _require.h,
    Component = _require.Component; // Grab our sketch & settings


var sketch = require('./background-sketch'); // The actual canvas-sketch library


var canvasSketch = require('canvas-sketch'); // Utility for preact className


var classnames = require('classnames');

module.exports =
/*#__PURE__*/
function (_Component) {
  _inherits(Canvas, _Component);

  function Canvas() {
    _classCallCheck(this, Canvas);

    return _possibleConstructorReturn(this, _getPrototypeOf(Canvas).apply(this, arguments));
  }

  _createClass(Canvas, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      // Since we render() the canvas, it will be the 'base' element
      var canvas = this.base; // Setup a new canvas-sketch

      this.sketch = canvasSketch(sketch, Object.assign({}, sketch.settings, {
        canvas: canvas
      }));

      this._handleActive(this.props);
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(newProps) {
      this._handleActive(newProps);
    }
  }, {
    key: "_handleActive",
    value: function _handleActive(newProps) {
      this.sketch.then(function (sketch) {
        if (newProps.active && !sketch.playing) sketch.play();else sketch.stop();
      });
    }
  }, {
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(newProps) {
      return newProps.active !== this.props.active;
    }
  }, {
    key: "render",
    value: function render() {
      var className = classnames('background-canvas', {
        active: this.props.active
      });
      return h("canvas", {
        className: className
      });
    }
  }]);

  return Canvas;
}(Component);

},{"./background-sketch":155,"canvas-sketch":1,"classnames":35,"preact":126}],155:[function(require,module,exports){
"use strict";

var _require = require('../../../examples/util/math'),
    clamp01 = _require.clamp01,
    linspace = _require.linspace;

var Painter = require('../../../examples/util/canvas-painter');

var Random = require('../../../examples/util/random');

var tween = require('../../../examples/util/tween');

var _require2 = require('gl-matrix'),
    vec2 = _require2.vec2;

var settings = {
  animate: true,
  hotkeys: false
};

var sketch = function sketch(app) {
  var friction = 0.98;
  var particleCount = 300;
  var maxConnections = 5;
  var currentSpawnInterval = 0;
  var currentSpawnTime = 0; // Simple utility for 2D line/circle drawing

  var painter = Painter(app.context); // Create a list of 'particle' objects

  var particles = Array.from(new Array(particleCount)).map(function () {
    return {// We'll fill in the properties dynamically in spawn()
    };
  });

  var nextParticle = function nextParticle() {
    return particles.find(function (p) {
      return !p.active;
    });
  };

  var spawn = function spawn() {
    var particle = nextParticle();
    if (!particle) return; // none left in pool
    // Mark particle as active, no longer in pool

    particle.active = true; // Reset time

    particle.time = 0; // Choose a new position, we are in 0..1 space here

    var center = [0.5, 0.5];
    var scale = 0.4;
    var offset = Random.gaussian(0, 0.05);
    particle.position = vec2.add([], Random.onSquare(scale + offset), center); // Set some new random properties

    particle.duration = Random.range(3, 5);
    particle.radius = Random.range(1, 2);
    particle.connectionRadius = Random.range(0.1, 0.2);
    particle.speed = 1 / 1000;
    particle.animationDuration = 1; // Use a random point on unit circle to get a random velocity vector

    particle.velocity = Random.onCircle(1, particle.velocity);
    return particle;
  };

  var spawnMultiple = function spawnMultiple() {
    var count = Random.rangeFloor(1, 6);

    for (var i = 0; i < count; i++) {
      spawn();
    }
  };

  var tick = function tick(_ref) {
    var deltaTime = _ref.deltaTime,
        width = _ref.width,
        height = _ref.height;
    currentSpawnTime += deltaTime;

    if (currentSpawnTime > currentSpawnInterval) {
      currentSpawnTime = 0;
      currentSpawnInterval = Random.range(0.25, 0.35);
      spawnMultiple();
    }

    particles.forEach(function (particle) {
      if (!particle.active) return; // ignore dead/unused particles

      particle.time += deltaTime;

      if (particle.time > particle.duration) {
        particle.active = false;
        return;
      } // Move along velocity


      vec2.scaleAndAdd(particle.position, particle.position, particle.velocity, particle.speed);
      vec2.scale(particle.velocity, particle.velocity, friction);
    });
  };

  var render = function render(_ref2) {
    var context = _ref2.context,
        deltaTime = _ref2.deltaTime,
        width = _ref2.width,
        height = _ref2.height;
    painter.clear({
      fill: 'white',
      width: width,
      height: height
    });
    context.save(); // Update & draw each particle

    particles.forEach(function (particle) {
      // Skip inactive particles
      if (!particle.active) return;
      var size = particle.radius * tween({
        time: particle.time,
        ease: 'quadOut',
        edge: particle.animationDuration,
        duration: particle.duration
      }); // Paint circle

      painter.circle({
        alpha: 0.2,
        position: [particle.position[0] * width, particle.position[1] * height],
        radius: size
      }); // Paint connections

      var connectionRadius = particle.connectionRadius;

      for (var i = 0, c = 0; i < particles.length && c < maxConnections; i++) {
        var other = particles[i];
        if (other === particle || !other.active) continue; // skip self

        var dist = vec2.distance(other.position, particle.position);

        if (dist <= connectionRadius) {
          var distStr = Math.sin(Math.PI * clamp01(dist / connectionRadius)); // Need to map from 0..1 to 0..screenSize

          var positions = [particle.position, other.position].map(function (p) {
            return [p[0] * width, p[1] * height];
          });
          painter.polyline(positions, {
            alpha: 0.2 * distStr,
            stroke: 'black',
            lineWidth: 0.25 * distStr
          });
          c++;
        }
      }
    });
    context.restore();
  };

  return {
    render: render,
    tick: tick
  };
};

module.exports = sketch;
module.exports.settings = settings;

},{"../../../examples/util/canvas-painter":16,"../../../examples/util/math":18,"../../../examples/util/random":19,"../../../examples/util/tween":20,"gl-matrix":83}],125:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Link = exports.Match = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _preact = require('preact');

var _preactRouter = require('preact-router');

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Match = exports.Match = function (_Component) {
	_inherits(Match, _Component);

	function Match() {
		var _temp, _this, _ret;

		_classCallCheck(this, Match);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.update = function (url) {
			_this.nextUrl = url;
			_this.setState({});
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	Match.prototype.componentDidMount = function componentDidMount() {
		_preactRouter.subscribers.push(this.update);
	};

	Match.prototype.componentWillUnmount = function componentWillUnmount() {
		_preactRouter.subscribers.splice(_preactRouter.subscribers.indexOf(this.update) >>> 0, 1);
	};

	Match.prototype.render = function render(props) {
		var url = this.nextUrl || (0, _preactRouter.getCurrentUrl)(),
		    path = url.replace(/\?.+$/, '');
		this.nextUrl = null;
		return props.children[0] && props.children[0]({
			url: url,
			path: path,
			matches: path === props.path
		});
	};

	return Match;
}(_preact.Component);

var Link = function Link(_ref) {
	var activeClassName = _ref.activeClassName,
	    path = _ref.path,
	    props = _objectWithoutProperties(_ref, ['activeClassName', 'path']);

	return (0, _preact.h)(
		Match,
		{ path: path || props.href },
		function (_ref2) {
			var matches = _ref2.matches;
			return (0, _preact.h)(_preactRouter.Link, _extends({}, props, { 'class': [props.class || props.className, matches && activeClassName].filter(Boolean).join(' ') }));
		}
	);
};

exports.Link = Link;
exports.default = Match;

Match.Link = Link;

},{"preact":126,"preact-router":124}],124:[function(require,module,exports){
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e(require("preact")):"function"==typeof define&&define.amd?define(["preact"],e):t.preactRouter=e(t.preact)}(this,function(t){function e(t,e){for(var n in e)t[n]=e[n];return t}function n(t,e,n){var r,o=/(?:\?([^#]*))?(#.*)?$/,u=t.match(o),a={};if(u&&u[1])for(var p=u[1].split("&"),c=0;c<p.length;c++){var f=p[c].split("=");a[decodeURIComponent(f[0])]=decodeURIComponent(f.slice(1).join("="))}t=i(t.replace(o,"")),e=i(e||"");for(var l=Math.max(t.length,e.length),s=0;s<l;s++)if(e[s]&&":"===e[s].charAt(0)){var h=e[s].replace(/(^\:|[+*?]+$)/g,""),d=(e[s].match(/[+*?]+$/)||C)[0]||"",g=~d.indexOf("+"),m=~d.indexOf("*"),y=t[s]||"";if(!y&&!m&&(d.indexOf("?")<0||g)){r=!1;break}if(a[h]=decodeURIComponent(y),g||m){a[h]=t.slice(s).map(decodeURIComponent).join("/");break}}else if(e[s]!==t[s]){r=!1;break}return(!0===n.default||!1!==r)&&a}function r(t,e){return t.rank<e.rank?1:t.rank>e.rank?-1:t.index-e.index}function o(t,e){return t.index=e,t.rank=p(t),t.attributes}function i(t){return t.replace(/(^\/+|\/+$)/g,"").split("/")}function u(t){return":"==t.charAt(0)?1+"*+?".indexOf(t.charAt(t.length-1))||4:5}function a(t){return i(t).map(u).join("")}function p(t){return t.attributes.default?0:a(t.attributes.path)}function c(t){return null!=t.__preactattr_||"undefined"!=typeof Symbol&&null!=t[Symbol.for("preactattr")]}function f(t,e){void 0===e&&(e="push"),R&&R[e]?R[e](t):"undefined"!=typeof history&&history[e+"State"]&&history[e+"State"](null,null,t)}function l(){var t;return t=R&&R.location?R.location:R&&R.getCurrentLocation?R.getCurrentLocation():"undefined"!=typeof location?location:x,""+(t.pathname||"")+(t.search||"")}function s(t,e){return void 0===e&&(e=!1),"string"!=typeof t&&t.url&&(e=t.replace,t=t.url),h(t)&&f(t,e?"replace":"push"),d(t)}function h(t){for(var e=U.length;e--;)if(U[e].canRoute(t))return!0;return!1}function d(t){for(var e=!1,n=0;n<U.length;n++)!0===U[n].routeTo(t)&&(e=!0);for(var r=k.length;r--;)k[r](t);return e}function g(t){if(t&&t.getAttribute){var e=t.getAttribute("href"),n=t.getAttribute("target");if(e&&e.match(/^\//g)&&(!n||n.match(/^_?self$/i)))return s(e)}}function m(t){if(0==t.button)return g(t.currentTarget||t.target||this),y(t)}function y(t){return t&&(t.stopImmediatePropagation&&t.stopImmediatePropagation(),t.stopPropagation&&t.stopPropagation(),t.preventDefault()),!1}function v(t){if(!(t.ctrlKey||t.metaKey||t.altKey||t.shiftKey||0!==t.button)){var e=t.target;do{if("A"===(e.nodeName+"").toUpperCase()&&e.getAttribute("href")&&c(e)){if(e.hasAttribute("native"))return;if(g(e))return y(t)}}while(e=e.parentNode)}}function b(){_||("function"==typeof addEventListener&&(R||addEventListener("popstate",function(){d(l())}),addEventListener("click",v)),_=!0)}var C={},R=null,U=[],k=[],x={},_=!1,A=function(i){function u(t){i.call(this,t),t.history&&(R=t.history),this.state={url:t.url||l()},b()}return i&&(u.__proto__=i),u.prototype=Object.create(i&&i.prototype),u.prototype.constructor=u,u.prototype.shouldComponentUpdate=function(t){return!0!==t.static||(t.url!==this.props.url||t.onChange!==this.props.onChange)},u.prototype.canRoute=function(t){return this.getMatchingChildren(this.props.children,t,!1).length>0},u.prototype.routeTo=function(t){return this._didRoute=!1,this.setState({url:t}),this.updating?this.canRoute(t):(this.forceUpdate(),this._didRoute)},u.prototype.componentWillMount=function(){U.push(this),this.updating=!0},u.prototype.componentDidMount=function(){var t=this;R&&(this.unlisten=R.listen(function(e){t.routeTo(""+(e.pathname||"")+(e.search||""))})),this.updating=!1},u.prototype.componentWillUnmount=function(){"function"==typeof this.unlisten&&this.unlisten(),U.splice(U.indexOf(this),1)},u.prototype.componentWillUpdate=function(){this.updating=!0},u.prototype.componentDidUpdate=function(){this.updating=!1},u.prototype.getMatchingChildren=function(i,u,a){return i.filter(o).sort(r).map(function(r){var o=n(u,r.attributes.path,r.attributes);if(o){if(!1!==a){var i={url:u,matches:o};return e(i,o),delete i.ref,delete i.key,t.cloneElement(r,i)}return r}}).filter(Boolean)},u.prototype.render=function(t,e){var n=t.children,r=t.onChange,o=e.url,i=this.getMatchingChildren(n,o,!0),u=i[0]||null;this._didRoute=!!u;var a=this.previousUrl;return o!==a&&(this.previousUrl=o,"function"==typeof r&&r({router:this,url:o,previous:a,active:i,current:u})),u},u}(t.Component),I=function(n){return t.h("a",e({onClick:m},n))},L=function(e){return t.h(e.component,e)};return A.subscribers=k,A.getCurrentUrl=l,A.route=s,A.Router=A,A.Route=L,A.Link=I,A});


},{"preact":126}],126:[function(require,module,exports){
!function() {
    'use strict';
    function VNode() {}
    function h(nodeName, attributes) {
        var lastSimple, child, simple, i, children = EMPTY_CHILDREN;
        for (i = arguments.length; i-- > 2; ) stack.push(arguments[i]);
        if (attributes && null != attributes.children) {
            if (!stack.length) stack.push(attributes.children);
            delete attributes.children;
        }
        while (stack.length) if ((child = stack.pop()) && void 0 !== child.pop) for (i = child.length; i--; ) stack.push(child[i]); else {
            if ('boolean' == typeof child) child = null;
            if (simple = 'function' != typeof nodeName) if (null == child) child = ''; else if ('number' == typeof child) child = String(child); else if ('string' != typeof child) simple = !1;
            if (simple && lastSimple) children[children.length - 1] += child; else if (children === EMPTY_CHILDREN) children = [ child ]; else children.push(child);
            lastSimple = simple;
        }
        var p = new VNode();
        p.nodeName = nodeName;
        p.children = children;
        p.attributes = null == attributes ? void 0 : attributes;
        p.key = null == attributes ? void 0 : attributes.key;
        if (void 0 !== options.vnode) options.vnode(p);
        return p;
    }
    function extend(obj, props) {
        for (var i in props) obj[i] = props[i];
        return obj;
    }
    function cloneElement(vnode, props) {
        return h(vnode.nodeName, extend(extend({}, vnode.attributes), props), arguments.length > 2 ? [].slice.call(arguments, 2) : vnode.children);
    }
    function enqueueRender(component) {
        if (!component.__d && (component.__d = !0) && 1 == items.push(component)) (options.debounceRendering || defer)(rerender);
    }
    function rerender() {
        var p, list = items;
        items = [];
        while (p = list.pop()) if (p.__d) renderComponent(p);
    }
    function isSameNodeType(node, vnode, hydrating) {
        if ('string' == typeof vnode || 'number' == typeof vnode) return void 0 !== node.splitText;
        if ('string' == typeof vnode.nodeName) return !node._componentConstructor && isNamedNode(node, vnode.nodeName); else return hydrating || node._componentConstructor === vnode.nodeName;
    }
    function isNamedNode(node, nodeName) {
        return node.__n === nodeName || node.nodeName.toLowerCase() === nodeName.toLowerCase();
    }
    function getNodeProps(vnode) {
        var props = extend({}, vnode.attributes);
        props.children = vnode.children;
        var defaultProps = vnode.nodeName.defaultProps;
        if (void 0 !== defaultProps) for (var i in defaultProps) if (void 0 === props[i]) props[i] = defaultProps[i];
        return props;
    }
    function createNode(nodeName, isSvg) {
        var node = isSvg ? document.createElementNS('http://www.w3.org/2000/svg', nodeName) : document.createElement(nodeName);
        node.__n = nodeName;
        return node;
    }
    function removeNode(node) {
        var parentNode = node.parentNode;
        if (parentNode) parentNode.removeChild(node);
    }
    function setAccessor(node, name, old, value, isSvg) {
        if ('className' === name) name = 'class';
        if ('key' === name) ; else if ('ref' === name) {
            if (old) old(null);
            if (value) value(node);
        } else if ('class' === name && !isSvg) node.className = value || ''; else if ('style' === name) {
            if (!value || 'string' == typeof value || 'string' == typeof old) node.style.cssText = value || '';
            if (value && 'object' == typeof value) {
                if ('string' != typeof old) for (var i in old) if (!(i in value)) node.style[i] = '';
                for (var i in value) node.style[i] = 'number' == typeof value[i] && !1 === IS_NON_DIMENSIONAL.test(i) ? value[i] + 'px' : value[i];
            }
        } else if ('dangerouslySetInnerHTML' === name) {
            if (value) node.innerHTML = value.__html || '';
        } else if ('o' == name[0] && 'n' == name[1]) {
            var useCapture = name !== (name = name.replace(/Capture$/, ''));
            name = name.toLowerCase().substring(2);
            if (value) {
                if (!old) node.addEventListener(name, eventProxy, useCapture);
            } else node.removeEventListener(name, eventProxy, useCapture);
            (node.__l || (node.__l = {}))[name] = value;
        } else if ('list' !== name && 'type' !== name && !isSvg && name in node) {
            setProperty(node, name, null == value ? '' : value);
            if (null == value || !1 === value) node.removeAttribute(name);
        } else {
            var ns = isSvg && name !== (name = name.replace(/^xlink:?/, ''));
            if (null == value || !1 === value) if (ns) node.removeAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase()); else node.removeAttribute(name); else if ('function' != typeof value) if (ns) node.setAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase(), value); else node.setAttribute(name, value);
        }
    }
    function setProperty(node, name, value) {
        try {
            node[name] = value;
        } catch (e) {}
    }
    function eventProxy(e) {
        return this.__l[e.type](options.event && options.event(e) || e);
    }
    function flushMounts() {
        var c;
        while (c = mounts.pop()) {
            if (options.afterMount) options.afterMount(c);
            if (c.componentDidMount) c.componentDidMount();
        }
    }
    function diff(dom, vnode, context, mountAll, parent, componentRoot) {
        if (!diffLevel++) {
            isSvgMode = null != parent && void 0 !== parent.ownerSVGElement;
            hydrating = null != dom && !('__preactattr_' in dom);
        }
        var ret = idiff(dom, vnode, context, mountAll, componentRoot);
        if (parent && ret.parentNode !== parent) parent.appendChild(ret);
        if (!--diffLevel) {
            hydrating = !1;
            if (!componentRoot) flushMounts();
        }
        return ret;
    }
    function idiff(dom, vnode, context, mountAll, componentRoot) {
        var out = dom, prevSvgMode = isSvgMode;
        if (null == vnode || 'boolean' == typeof vnode) vnode = '';
        if ('string' == typeof vnode || 'number' == typeof vnode) {
            if (dom && void 0 !== dom.splitText && dom.parentNode && (!dom._component || componentRoot)) {
                if (dom.nodeValue != vnode) dom.nodeValue = vnode;
            } else {
                out = document.createTextNode(vnode);
                if (dom) {
                    if (dom.parentNode) dom.parentNode.replaceChild(out, dom);
                    recollectNodeTree(dom, !0);
                }
            }
            out.__preactattr_ = !0;
            return out;
        }
        var vnodeName = vnode.nodeName;
        if ('function' == typeof vnodeName) return buildComponentFromVNode(dom, vnode, context, mountAll);
        isSvgMode = 'svg' === vnodeName ? !0 : 'foreignObject' === vnodeName ? !1 : isSvgMode;
        vnodeName = String(vnodeName);
        if (!dom || !isNamedNode(dom, vnodeName)) {
            out = createNode(vnodeName, isSvgMode);
            if (dom) {
                while (dom.firstChild) out.appendChild(dom.firstChild);
                if (dom.parentNode) dom.parentNode.replaceChild(out, dom);
                recollectNodeTree(dom, !0);
            }
        }
        var fc = out.firstChild, props = out.__preactattr_, vchildren = vnode.children;
        if (null == props) {
            props = out.__preactattr_ = {};
            for (var a = out.attributes, i = a.length; i--; ) props[a[i].name] = a[i].value;
        }
        if (!hydrating && vchildren && 1 === vchildren.length && 'string' == typeof vchildren[0] && null != fc && void 0 !== fc.splitText && null == fc.nextSibling) {
            if (fc.nodeValue != vchildren[0]) fc.nodeValue = vchildren[0];
        } else if (vchildren && vchildren.length || null != fc) innerDiffNode(out, vchildren, context, mountAll, hydrating || null != props.dangerouslySetInnerHTML);
        diffAttributes(out, vnode.attributes, props);
        isSvgMode = prevSvgMode;
        return out;
    }
    function innerDiffNode(dom, vchildren, context, mountAll, isHydrating) {
        var j, c, f, vchild, child, originalChildren = dom.childNodes, children = [], keyed = {}, keyedLen = 0, min = 0, len = originalChildren.length, childrenLen = 0, vlen = vchildren ? vchildren.length : 0;
        if (0 !== len) for (var i = 0; i < len; i++) {
            var _child = originalChildren[i], props = _child.__preactattr_, key = vlen && props ? _child._component ? _child._component.__k : props.key : null;
            if (null != key) {
                keyedLen++;
                keyed[key] = _child;
            } else if (props || (void 0 !== _child.splitText ? isHydrating ? _child.nodeValue.trim() : !0 : isHydrating)) children[childrenLen++] = _child;
        }
        if (0 !== vlen) for (var i = 0; i < vlen; i++) {
            vchild = vchildren[i];
            child = null;
            var key = vchild.key;
            if (null != key) {
                if (keyedLen && void 0 !== keyed[key]) {
                    child = keyed[key];
                    keyed[key] = void 0;
                    keyedLen--;
                }
            } else if (!child && min < childrenLen) for (j = min; j < childrenLen; j++) if (void 0 !== children[j] && isSameNodeType(c = children[j], vchild, isHydrating)) {
                child = c;
                children[j] = void 0;
                if (j === childrenLen - 1) childrenLen--;
                if (j === min) min++;
                break;
            }
            child = idiff(child, vchild, context, mountAll);
            f = originalChildren[i];
            if (child && child !== dom && child !== f) if (null == f) dom.appendChild(child); else if (child === f.nextSibling) removeNode(f); else dom.insertBefore(child, f);
        }
        if (keyedLen) for (var i in keyed) if (void 0 !== keyed[i]) recollectNodeTree(keyed[i], !1);
        while (min <= childrenLen) if (void 0 !== (child = children[childrenLen--])) recollectNodeTree(child, !1);
    }
    function recollectNodeTree(node, unmountOnly) {
        var component = node._component;
        if (component) unmountComponent(component); else {
            if (null != node.__preactattr_ && node.__preactattr_.ref) node.__preactattr_.ref(null);
            if (!1 === unmountOnly || null == node.__preactattr_) removeNode(node);
            removeChildren(node);
        }
    }
    function removeChildren(node) {
        node = node.lastChild;
        while (node) {
            var next = node.previousSibling;
            recollectNodeTree(node, !0);
            node = next;
        }
    }
    function diffAttributes(dom, attrs, old) {
        var name;
        for (name in old) if ((!attrs || null == attrs[name]) && null != old[name]) setAccessor(dom, name, old[name], old[name] = void 0, isSvgMode);
        for (name in attrs) if (!('children' === name || 'innerHTML' === name || name in old && attrs[name] === ('value' === name || 'checked' === name ? dom[name] : old[name]))) setAccessor(dom, name, old[name], old[name] = attrs[name], isSvgMode);
    }
    function collectComponent(component) {
        var name = component.constructor.name;
        (components[name] || (components[name] = [])).push(component);
    }
    function createComponent(Ctor, props, context) {
        var inst, list = components[Ctor.name];
        if (Ctor.prototype && Ctor.prototype.render) {
            inst = new Ctor(props, context);
            Component.call(inst, props, context);
        } else {
            inst = new Component(props, context);
            inst.constructor = Ctor;
            inst.render = doRender;
        }
        if (list) for (var i = list.length; i--; ) if (list[i].constructor === Ctor) {
            inst.__b = list[i].__b;
            list.splice(i, 1);
            break;
        }
        return inst;
    }
    function doRender(props, state, context) {
        return this.constructor(props, context);
    }
    function setComponentProps(component, props, opts, context, mountAll) {
        if (!component.__x) {
            component.__x = !0;
            if (component.__r = props.ref) delete props.ref;
            if (component.__k = props.key) delete props.key;
            if (!component.base || mountAll) {
                if (component.componentWillMount) component.componentWillMount();
            } else if (component.componentWillReceiveProps) component.componentWillReceiveProps(props, context);
            if (context && context !== component.context) {
                if (!component.__c) component.__c = component.context;
                component.context = context;
            }
            if (!component.__p) component.__p = component.props;
            component.props = props;
            component.__x = !1;
            if (0 !== opts) if (1 === opts || !1 !== options.syncComponentUpdates || !component.base) renderComponent(component, 1, mountAll); else enqueueRender(component);
            if (component.__r) component.__r(component);
        }
    }
    function renderComponent(component, opts, mountAll, isChild) {
        if (!component.__x) {
            var rendered, inst, cbase, props = component.props, state = component.state, context = component.context, previousProps = component.__p || props, previousState = component.__s || state, previousContext = component.__c || context, isUpdate = component.base, nextBase = component.__b, initialBase = isUpdate || nextBase, initialChildComponent = component._component, skip = !1;
            if (isUpdate) {
                component.props = previousProps;
                component.state = previousState;
                component.context = previousContext;
                if (2 !== opts && component.shouldComponentUpdate && !1 === component.shouldComponentUpdate(props, state, context)) skip = !0; else if (component.componentWillUpdate) component.componentWillUpdate(props, state, context);
                component.props = props;
                component.state = state;
                component.context = context;
            }
            component.__p = component.__s = component.__c = component.__b = null;
            component.__d = !1;
            if (!skip) {
                rendered = component.render(props, state, context);
                if (component.getChildContext) context = extend(extend({}, context), component.getChildContext());
                var toUnmount, base, childComponent = rendered && rendered.nodeName;
                if ('function' == typeof childComponent) {
                    var childProps = getNodeProps(rendered);
                    inst = initialChildComponent;
                    if (inst && inst.constructor === childComponent && childProps.key == inst.__k) setComponentProps(inst, childProps, 1, context, !1); else {
                        toUnmount = inst;
                        component._component = inst = createComponent(childComponent, childProps, context);
                        inst.__b = inst.__b || nextBase;
                        inst.__u = component;
                        setComponentProps(inst, childProps, 0, context, !1);
                        renderComponent(inst, 1, mountAll, !0);
                    }
                    base = inst.base;
                } else {
                    cbase = initialBase;
                    toUnmount = initialChildComponent;
                    if (toUnmount) cbase = component._component = null;
                    if (initialBase || 1 === opts) {
                        if (cbase) cbase._component = null;
                        base = diff(cbase, rendered, context, mountAll || !isUpdate, initialBase && initialBase.parentNode, !0);
                    }
                }
                if (initialBase && base !== initialBase && inst !== initialChildComponent) {
                    var baseParent = initialBase.parentNode;
                    if (baseParent && base !== baseParent) {
                        baseParent.replaceChild(base, initialBase);
                        if (!toUnmount) {
                            initialBase._component = null;
                            recollectNodeTree(initialBase, !1);
                        }
                    }
                }
                if (toUnmount) unmountComponent(toUnmount);
                component.base = base;
                if (base && !isChild) {
                    var componentRef = component, t = component;
                    while (t = t.__u) (componentRef = t).base = base;
                    base._component = componentRef;
                    base._componentConstructor = componentRef.constructor;
                }
            }
            if (!isUpdate || mountAll) mounts.unshift(component); else if (!skip) {
                if (component.componentDidUpdate) component.componentDidUpdate(previousProps, previousState, previousContext);
                if (options.afterUpdate) options.afterUpdate(component);
            }
            if (null != component.__h) while (component.__h.length) component.__h.pop().call(component);
            if (!diffLevel && !isChild) flushMounts();
        }
    }
    function buildComponentFromVNode(dom, vnode, context, mountAll) {
        var c = dom && dom._component, originalComponent = c, oldDom = dom, isDirectOwner = c && dom._componentConstructor === vnode.nodeName, isOwner = isDirectOwner, props = getNodeProps(vnode);
        while (c && !isOwner && (c = c.__u)) isOwner = c.constructor === vnode.nodeName;
        if (c && isOwner && (!mountAll || c._component)) {
            setComponentProps(c, props, 3, context, mountAll);
            dom = c.base;
        } else {
            if (originalComponent && !isDirectOwner) {
                unmountComponent(originalComponent);
                dom = oldDom = null;
            }
            c = createComponent(vnode.nodeName, props, context);
            if (dom && !c.__b) {
                c.__b = dom;
                oldDom = null;
            }
            setComponentProps(c, props, 1, context, mountAll);
            dom = c.base;
            if (oldDom && dom !== oldDom) {
                oldDom._component = null;
                recollectNodeTree(oldDom, !1);
            }
        }
        return dom;
    }
    function unmountComponent(component) {
        if (options.beforeUnmount) options.beforeUnmount(component);
        var base = component.base;
        component.__x = !0;
        if (component.componentWillUnmount) component.componentWillUnmount();
        component.base = null;
        var inner = component._component;
        if (inner) unmountComponent(inner); else if (base) {
            if (base.__preactattr_ && base.__preactattr_.ref) base.__preactattr_.ref(null);
            component.__b = base;
            removeNode(base);
            collectComponent(component);
            removeChildren(base);
        }
        if (component.__r) component.__r(null);
    }
    function Component(props, context) {
        this.__d = !0;
        this.context = context;
        this.props = props;
        this.state = this.state || {};
    }
    function render(vnode, parent, merge) {
        return diff(merge, vnode, {}, !1, parent, !1);
    }
    var options = {};
    var stack = [];
    var EMPTY_CHILDREN = [];
    var defer = 'function' == typeof Promise ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout;
    var IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;
    var items = [];
    var mounts = [];
    var diffLevel = 0;
    var isSvgMode = !1;
    var hydrating = !1;
    var components = {};
    extend(Component.prototype, {
        setState: function(state, callback) {
            var s = this.state;
            if (!this.__s) this.__s = extend({}, s);
            extend(s, 'function' == typeof state ? state(s, this.props) : state);
            if (callback) (this.__h = this.__h || []).push(callback);
            enqueueRender(this);
        },
        forceUpdate: function(callback) {
            if (callback) (this.__h = this.__h || []).push(callback);
            renderComponent(this, 2);
        },
        render: function() {}
    });
    var preact = {
        h: h,
        createElement: h,
        cloneElement: cloneElement,
        Component: Component,
        render: render,
        rerender: rerender,
        options: options
    };
    if ('undefined' != typeof module) module.exports = preact; else self.preact = preact;
}();

},{}],35:[function(require,module,exports){
/*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg) && arg.length) {
				var inner = classNames.apply(null, arg);
				if (inner) {
					classes.push(inner);
				}
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
		// register as 'classnames', consistent with npm package name
		define('classnames', [], function () {
			return classNames;
		});
	} else {
		window.classNames = classNames;
	}
}());

},{}],16:[function(require,module,exports){
"use strict";

var defined = require('defined');

var _require = require('./math'),
    expand2D = _require.expand2D;

module.exports = function (context) {
  var paint = function paint() {
    var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var fill = opt.fill;
    var stroke = opt.stroke;
    var defaultColor = 'black';
    var alpha = defined(opt.alpha, 1); // Default to fill-only

    if (opt.fill == null && opt.stroke == null) fill = true;

    if (fill) {
      var fillAlpha = defined(opt.fillAlpha, 1);
      context.fillStyle = typeof fill === 'boolean' ? defaultColor : fill;
      context.globalAlpha = alpha * fillAlpha;
      context.fill();
    }

    var lineWidth = defined(opt.lineWidth, 1);

    if (stroke && lineWidth > 0) {
      var strokeAlpha = defined(opt.strokeAlpha, 1);
      context.strokeStyle = typeof stroke === 'boolean' ? defaultColor : stroke;
      context.lineWidth = lineWidth;
      context.lineCap = opt.lineCap || 'butt';
      context.lineJoin = opt.lineJoin || 'miter';
      context.miterLimit = defined(opt.miterLimit, 10);
      context.globalAlpha = alpha * strokeAlpha;
      context.stroke();
    }
  };

  var circle = function circle() {
    var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    context.beginPath();
    var radius = Math.max(0, defined(opt.radius, 1));
    var position = expand2D(opt.position);
    var arcStart = defined(opt.arcStart, 0);
    var arcEnd = defined(opt.arcEnd, Math.PI * 2);
    context.arc(position[0], position[1], radius, arcStart, arcEnd, false);
    paint(opt);
  };

  var rect = function rect() {
    var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    context.beginPath();
    var position = expand2D(opt.position);
    var width = defined(opt.width, 1);
    var height = defined(opt.height, 1);
    context.rect(position[0], position[1], width, height);
    paint(opt);
  };

  var _line = function _line(path) {
    var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var defaultToStroke = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    opt = Object.assign({}, opt);

    if (defaultToStroke) {
      if (opt.fill == null && opt.stroke == null) opt.stroke = true;
    }

    context.beginPath();
    path.forEach(function (point) {
      return context.lineTo(point[0], point[1]);
    });
    if (opt.closed) context.closePath();
    paint(opt);
  };

  var polyline = function polyline(path) {
    var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return _line(path, opt, true);
  };

  var shape = function shape(_shape) {
    var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return _line(_shape, opt, false);
  };

  var polylines = function polylines(lines) {
    var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    lines.forEach(function (path) {
      return polyline(path, opt);
    });
  };

  var clear = function clear() {
    var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var position = expand2D(opt.position);
    var width = defined(opt.width, context.canvas.width);
    var height = defined(opt.height, context.canvas.height); // clear first in case we have a translucent fill

    context.clearRect(position[0], position[1], width, height); // now allow user to fill

    if (opt.fill) {
      context.beginPath();
      context.rect(position[0], position[1], width, height);
      paint(opt);
    }
  };

  return {
    clear: clear,
    paint: paint,
    rect: rect,
    circle: circle,
    polyline: polyline,
    polylines: polylines,
    shape: shape
  };
};

},{"./math":18,"defined":41}]},{},[159])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9mYWN0b3ItYnVuZGxlL25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJ3ZWJzaXRlL3NyYy9pbmRleC5qcyIsIndlYnNpdGUvc3JjL2NvbXBvbmVudHMvRXhhbXBsZXMuanMiLCJ3ZWJzaXRlL3NyYy9kYXRhL2luZGV4LmpzIiwid2Vic2l0ZS9zcmMvZGF0YS9nZXRTZWN0aW9uRGF0YS5qcyIsIndlYnNpdGUvc3JjL2RhdGEvZXhhbXBsZXMtZGF0YS5qc29uIiwid2Vic2l0ZS9zcmMvY29tcG9uZW50cy9DYW52YXMuanMiLCJ3ZWJzaXRlL3NyYy9jb21wb25lbnRzL2JhY2tncm91bmQtc2tldGNoLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC1yb3V0ZXIvbWF0Y2guanMiLCJub2RlX21vZHVsZXMvcHJlYWN0LXJvdXRlci9kaXN0L3ByZWFjdC1yb3V0ZXIuanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L2Rpc3QvcHJlYWN0LmpzIiwibm9kZV9tb2R1bGVzL2NsYXNzbmFtZXMvaW5kZXguanMiLCJleGFtcGxlcy91dGlsL2NhbnZhcy1wYWludGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDQUE7QUFDQSxJQUFNLFNBQVMsUUFBUSxlQUFSLENBQWY7O2VBRXNCLFFBQVEsUUFBUixDO0lBQWQsQyxZQUFBLEM7SUFBRyxNLFlBQUEsTTs7Z0JBQ00sUUFBUSxxQkFBUixDO0lBQVQsSSxhQUFBLEk7O0FBQ1IsSUFBTSxTQUFTLFFBQVEscUJBQVIsQ0FBZjs7QUFDQSxJQUFNLFdBQVcsUUFBUSx1QkFBUixDQUFqQjs7QUFFQSxJQUFNLFlBQVksMkNBQWxCO0FBQ0EsSUFBTSxnQkFBZ0Isc0VBQXRCOztBQUVBLElBQU0sU0FBUyxTQUFULE1BQVMsR0FBTTtBQUNuQixTQUFPO0FBQUssZUFBVTtBQUFmLEtBQ0wsa0JBQ0UsRUFBQyxJQUFEO0FBQU0sVUFBSyxH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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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UyxDQUFULENBQTFCLEVBQXVDLEtBQXZDLEVBQThDLE1BQTlDO0FBQ0EsWUFBTSxHQUFOO0FBQ0Q7QUFDRixHQWREOztBQWdCQSxTQUFPO0FBQ0wsZ0JBREs7QUFFTCxnQkFGSztBQUdMLGNBSEs7QUFJTCxrQkFKSztBQUtMLHNCQUxLO0FBTUwsd0JBTks7QUFPTDtBQVBLLEdBQVA7QUFTRCxDQTdGRCIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKiogQGpzeCBoICovXG5jb25zdCBSb3V0ZXIgPSByZXF1aXJlKCdwcmVhY3Qtcm91dGVyJyk7XG5cbmNvbnN0IHsgaCwgcmVuZGVyIH0gPSByZXF1aXJlKCdwcmVhY3QnKTtcbmNvbnN0IHsgTGluayB9ID0gcmVxdWlyZSgncHJlYWN0LXJvdXRlci9tYXRjaCcpO1xuY29uc3QgQ2FudmFzID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL0NhbnZhcycpO1xuY29uc3QgRXhhbXBsZXMgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvRXhhbXBsZXMnKTtcblxuY29uc3QgZ2l0SHViVXJsID0gJ2h0dHBzOi8vZ2l0aHViLmNvbS9tYXR0ZGVzbC9jYW52YXMtc2tldGNoJztcbmNvbnN0IGdpdEh1YlVybERvY3MgPSAnaHR0cHM6Ly9naXRodWIuY29tL21hdHRkZXNsL2NhbnZhcy1za2V0Y2gvYmxvYi9tYXN0ZXIvZG9jcy9SRUFETUUubWQnO1xuXG5jb25zdCBOYXZiYXIgPSAoKSA9PiB7XG4gIHJldHVybiA8ZGl2IGNsYXNzTmFtZT0ndG9wLW5hdic+XG4gICAgPGhlYWRlcj5cbiAgICAgIDxMaW5rIGhyZWY9Jy8nIGNsYXNzTmFtZT0ndGl0bGUnPmNhbnZhcy1za2V0Y2g8L0xpbms+XG4gICAgICA8bmF2PlxuICAgICAgICA8TGluayBhY3RpdmVDbGFzc05hbWU9J2FjdGl2ZScgaHJlZj0nL2V4YW1wbGVzJz5leGFtcGxlczwvTGluaz5cbiAgICAgICAgPGEgdGFyZ2V0PSdfYmxhbmsnIGhyZWY9e2dpdEh1YlVybERvY3N9IGNsYXNzTmFtZT0nZXh0ZXJuYWwnPmRvY3M8L2E+XG4gICAgICAgIDxhIHRhcmdldD0nX2JsYW5rJyBocmVmPXtnaXRIdWJVcmx9IGNsYXNzTmFtZT0nZXh0ZXJuYWwnPmNvZGU8L2E+XG4gICAgICA8L25hdj5cbiAgICA8L2hlYWRlcj5cbiAgPC9kaXY+O1xufTtcblxuY29uc3QgRm9vdGVyID0gKCkgPT4ge1xuICByZXR1cm4gPGZvb3Rlcj5cbiAgICA8ZGl2IGNsYXNzTmFtZT0ncm90YXRlZC1icmllZic+YSB0b29sa2l0IGZvciBnZW5lcmF0aXZlIGFydDwvZGl2PlxuICAgIDxociBjbGFzc05hbWU9J3JpZ2h0JyAvPlxuICA8L2Zvb3Rlcj47XG59O1xuXG5jb25zdCBIb21lID0gKCkgPT4ge1xuICByZXR1cm4gPG1haW4gY2xhc3NOYW1lPSdsYW5kaW5nJz5cbiAgICA8cD48c3Ryb25nPmNhbnZhcy1za2V0Y2g8L3N0cm9uZz4gaXMgYSBsb29zZSBjb2xsZWN0aW9uIG9mIHRvb2xzLCBtb2R1bGVzLCBhbmQgcmVzb3VyY2VzIGZvciBjcmVhdGluZyBnZW5lcmF0aXZlIGFydCBpbiBKYXZhU2NyaXB0IGFuZCB0aGUgYnJvd3Nlci48L3A+XG4gICAgPHA+SXQgY2FuIGJlIHVzZWQgdG8gcmVuZGVyIGhpZ2gtcXVhbGl0eSBQTkcgaW1hZ2VzIGZvciBHaWNsw6llIHByaW50cywgY3JlYXRlIHJlYWwtdGltZSB3ZWIgZ3JhcGhpY3MgKHN1Y2ggYXMgdGhpcyBwYWdlJ3MgYmFja2dyb3VuZCksIGV4cG9ydCBpbWFnZSBzZXF1ZW5jZXMgZm9yIEdJRiBhbmQgTVA0IGxvb3BzLCBnZW5lcmF0ZSBTVkcgZmlsZXMgZm9yIHBlbiBwbG90dGVycyAobGlrZSBBeGlEcmF3KSwgYXV0b21hdGljYWxseSBnaXQgaGFzaCB5b3VyIGFydHdvcmtzIGZvciBsb25nLXRlcm0gYXJjaGl2aW5nLCBhbmQgbW9yZS48L3A+XG4gICAgPHA+VG8gZ2V0IHN0YXJ0ZWQsIGNoZWNrIG91dCB0aGUgPGEgdGFyZ2V0PSdfYmxhbmsnIGhyZWY9e2dpdEh1YlVybERvY3N9PmRvY3VtZW50YXRpb248L2E+LFxuICAgIG9yIGJyb3dzZSB0aHJvdWdoIDxMaW5rIGhyZWY9Jy9leGFtcGxlcyc+c29tZSBleGFtcGxlczwvTGluaz4sXG4gICAgb3IgdmlldyB0aGUgPGEgdGFyZ2V0PSdfYmxhbmsnIGhyZWY9e2dpdEh1YlVybH0+c291cmNlIGNvZGU8L2E+IG9uIEdpdEh1Yi48L3A+XG4gIDwvbWFpbj47XG59O1xuXG5jb25zdCBEb2NzID0gKCkgPT4ge1xuICByZXR1cm4gPG1haW4+RG9jcy4uLjwvbWFpbj47XG59O1xuXG5jbGFzcyBDb250ZW50IGV4dGVuZHMgUm91dGVyIHtcbiAgcmVuZGVyIChwcm9wcywgc3RhdGUpIHtcbiAgICBjb25zdCBpc0hvbWUgPSBzdGF0ZS51cmwgPT09ICcvJztcbiAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9J2NvbnRlbnQtbGF5ZXInPlxuICAgICAgPENhbnZhcyBhY3RpdmU9e2lzSG9tZX0gLz5cbiAgICAgIDxOYXZiYXIgLz5cbiAgICAgIHsgc3VwZXIucmVuZGVyKHByb3BzLCBzdGF0ZSkgfVxuICAgICAgeyBpc0hvbWUgJiYgPEZvb3RlciAvPiB9XG4gICAgPC9kaXY+O1xuICB9XG59XG5cbmNvbnN0IEFwcCA9IChwcm9wcywgY29udGV4dCkgPT4ge1xuICByZXR1cm4gPGRpdiBjbGFzc05hbWU9J2FwcCc+XG4gICAgPENvbnRlbnQ+XG4gICAgICA8SG9tZSBwYXRoPScvJyAvPlxuICAgICAgPEV4YW1wbGVzIHBhdGg9Jy9leGFtcGxlcy86bmFtZT8nIC8+XG4gICAgPC9Db250ZW50PlxuICA8L2Rpdj47XG59O1xuXG5yZW5kZXIoPEFwcCAvPiwgZG9jdW1lbnQuYm9keSk7XG4iLCIvKiogQGpzeCBoICovXG5jb25zdCBjbGFzc25hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xuY29uc3QgeyByb3V0ZSB9ID0gcmVxdWlyZSgncHJlYWN0LXJvdXRlcicpO1xuY29uc3QgeyBoLCBDb21wb25lbnQgfSA9IHJlcXVpcmUoJ3ByZWFjdCcpO1xuY29uc3QgeyBMaW5rIH0gPSByZXF1aXJlKCdwcmVhY3Qtcm91dGVyL21hdGNoJyk7XG5cbmNvbnN0IHsgZXhhbXBsZXMgfSA9IHJlcXVpcmUoJy4uL2RhdGEnKTtcblxuY29uc3QgY2FjaGVkU291cmNlID0ge307XG5cbmNvbnN0IGdldFNvdXJjZSA9IChuYW1lKSA9PiB7XG4gIGNvbnN0IHVybCA9IGAvZXhhbXBsZXMvJHtuYW1lfS5qc2A7XG4gIGlmICh1cmwgaW4gY2FjaGVkU291cmNlKSByZXR1cm4gY2FjaGVkU291cmNlW3VybF07XG4gIGNvbnN0IHAgPSB3aW5kb3cuZmV0Y2godXJsKS50aGVuKHJlc3AgPT4gcmVzcC50ZXh0KCkpO1xuICBjYWNoZWRTb3VyY2VbdXJsXSA9IHA7XG4gIHJldHVybiBwO1xufTtcblxuY29uc3QgRXhhbXBsZUl0ZW0gPSAocHJvcHMpID0+IHtcbiAgY29uc3QgYmFzZVVybCA9ICcvZXhhbXBsZXMnO1xuICBjb25zdCB1cmwgPSBgJHtiYXNlVXJsfS8ke3Byb3BzLm5hbWV9YDtcbiAgcmV0dXJuIDxsaT5cbiAgICA8TGluayBhY3RpdmVDbGFzc05hbWU9J2FjdGl2ZScgaHJlZj17dXJsfT57cHJvcHMudGl0bGV9PC9MaW5rPlxuICA8L2xpPjtcbn07XG5cbmNsYXNzIFZpZXcgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAgY29kZTogJydcbiAgICB9O1xuICB9XG5cbiAgbG9hZFNrZXRjaCAocHJvcHMpIHtcbiAgICBjb25zdCBuYW1lID0gcHJvcHMubmFtZTtcbiAgICAvLyBJZiB3ZSBoYXZlIGEgbmFtZSwgc3RhcnQgbG9hZGluZ1xuICAgIGNvbnN0IGxvYWRpbmcgPSBCb29sZWFuKG5hbWUpO1xuICAgIHRoaXMuc2V0U3RhdGUoeyBsb2FkaW5nLCBjb2RlOiAnJyB9KTtcbiAgICBnZXRTb3VyY2UobmFtZSkudGhlbihjb2RlID0+IHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBsb2FkaW5nOiBmYWxzZSwgY29kZSB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgKHByb3BzLCBzdGF0ZSkge1xuICAgIHRoaXMubG9hZFNrZXRjaChwcm9wcyk7XG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCAoKSB7XG4gICAgdGhpcy5sb2FkU2tldGNoKHRoaXMucHJvcHMpO1xuICB9XG5cbiAgY29tcG9uZW50RGlkVXBkYXRlICgpIHtcbiAgICBpZiAodGhpcy5lbGVtZW50ICYmIHdpbmRvdy5obGpzICYmIHRoaXMuc3RhdGUuY29kZSAmJiB0aGlzLmVsZW1lbnQucGFyZW50RWxlbWVudCkge1xuICAgICAgdGhpcy5lbGVtZW50LmlubmVySFRNTCA9IHRoaXMuc3RhdGUuY29kZTtcbiAgICAgIHdpbmRvdy5obGpzLmhpZ2hsaWdodEJsb2NrKHRoaXMuZWxlbWVudC5wYXJlbnRFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZW5kZXIgKHByb3BzKSB7XG4gICAgY29uc3QgbmFtZSA9IHByb3BzLm5hbWU7XG5cbiAgICAvLyBVc2VyIHNlbGVjdGVkIGFuIGV4YW1wbGVcbiAgICBpZiAobmFtZSkge1xuICAgICAgaWYgKG5hbWUgaW4gZXhhbXBsZXMubWFwKSB7XG4gICAgICAgIC8vIFNrZXRjaCBleGlzdHMhXG4gICAgICAgIGNvbnN0IGNvZGUgPSB0aGlzLnN0YXRlLmNvZGU7XG4gICAgICAgIGlmIChjb2RlKSB7XG4gICAgICAgICAgY29uc3Qgc2tldGNoID0gZXhhbXBsZXMubWFwW25hbWVdO1xuICAgICAgICAgIGNvbnN0IGNsYXNzZXMgPSBjbGFzc25hbWVzKCdjb2RlJywgeyBsb2FkaW5nOiAhY29kZSB9KTtcbiAgICAgICAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9J3NrZXRjaC12aWV3Jz5cbiAgICAgICAgICAgIDxpZnJhbWUgY2xhc3NOYW1lPSdza2V0Y2gnIHNyYz17YGV4YW1wbGVzL2J1aWxkLyR7c2tldGNoLm5hbWV9Lmh0bWxgfSB3aWR0aD0nMTAwJScgaGVpZ2h0PScxMDAlJyAvPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzZXN9PlxuICAgICAgICAgICAgICA8cHJlPlxuICAgICAgICAgICAgICAgIDxjb2RlIGNsYXNzTmFtZT0nanMnIHJlZj17YyA9PiB7IHRoaXMuZWxlbWVudCA9IGM7IH19IC8+XG4gICAgICAgICAgICAgIDwvcHJlPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiA8ZGl2IGNsYXNzTmFtZT0nc2tldGNoLXZpZXcgbm8tc2tldGNoJz48cD5sb2FkaW5nPC9wPjwvZGl2PjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2tldGNoIGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgY29uc29sZS53YXJuKGBDb3VsZCBub3QgZmluZCBleGFtcGxlIGJ5IGlkICR7bmFtZX1gKTtcbiAgICAgICAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPSdza2V0Y2gtdmlldyBuby1za2V0Y2gnPjxwPk5vIHNrZXRjaCBmb3VuZCBieSB0aGUgbmFtZSA8c3Ryb25nPntuYW1lfTwvc3Ryb25nPiw8L3A+PHA+dHJ5IGNob29zaW5nIGEgZGlmZmVyZW50IG9uZSBmcm9tIHRoZSBsaXN0PC9wPjwvZGl2PjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9J3NrZXRjaC12aWV3IG5vLXNrZXRjaCc+XG4gICAgICA8cD5DaG9vc2UgYSBza2V0Y2ggZnJvbSB0aGUgbGlzdCB0byBiZWdpbi48L3A+XG4gICAgICB7LyogSXQncyBhIGJpdCBhd2t3YXJkIHNpbmNlIHRoZSB1c2VyIGhhcyB0byBjbGljayB0aGUgaWZyYW1lIHRvIGdhaW4gZm9jdXMgZmlyc3QuLi4gOlxcICovfVxuICAgICAgey8qIDxwIGNsYXNzTmFtZT0naG90a2V5LXRpcCc+V2hpbGUgdmlld2luZyBhIHNrZXRjaCwgcHVzaCA8Y29kZSBjbGFzc05hbWU9J2hvdGtleSc+Q3RybCArIFM8L2NvZGU+IG9yIDxjb2RlIGNsYXNzTmFtZT0naG90a2V5Jz5DbWQgKyBTPC9jb2RlPiB0byBkb3dubG9hZCB0aGUgYXJ0d29yay48L3A+ICovfVxuICAgIDwvZGl2PjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IChwcm9wcywgY29udGV4dCkgPT4ge1xuICBjb25zdCBzZWN0aW9ucyA9IGV4YW1wbGVzLmRhdGEubWFwKHNlY3Rpb24gPT4ge1xuICAgIGlmICghc2VjdGlvbi5uYW1lKSB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgXCJuYW1lXCIgZmllbGQgaW4gc2VjdGlvbiBmcm9tIGV4YW1wbGVzLWRhdGEuanNvbicpO1xuICAgIGNvbnN0IGl0ZW1EYXRhID0gc2VjdGlvbi5pdGVtcyB8fCBbXTtcbiAgICBjb25zdCBpdGVtcyA9IGl0ZW1EYXRhLmZpbHRlcihkID0+IGQudmlzaWJsZSAhPT0gZmFsc2UpLm1hcChkYXRhID0+IHtcbiAgICAgIHJldHVybiA8RXhhbXBsZUl0ZW0gey4uLmRhdGF9IG5hbWU9e2RhdGEubmFtZX0gLz47XG4gICAgfSk7XG4gICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIDx1bCBjbGFzc05hbWU9J2V4YW1wbGVzJz5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPSdsaXN0LXNlY3Rpb24taGVhZGVyJz57c2VjdGlvbi50aXRsZX08L2Rpdj5cbiAgICAgIHtpdGVtc31cbiAgICA8L3VsPjtcbiAgfSkuZmlsdGVyKEJvb2xlYW4pO1xuXG4gIGxldCBuYW1lID0gcHJvcHMubWF0Y2hlcy5uYW1lIHx8ICcnO1xuICBjb25zdCB2aWV3ID0gPFZpZXcgbmFtZT17bmFtZX0gLz47XG4gIHJldHVybiA8bWFpbiBjbGFzc05hbWU9J3NwbGl0LXZpZXcnPlxuICAgIDxkaXYgY2xhc3NOYW1lPSdsaXN0LXZpZXcnPlxuICAgICAgPGRpdiBjbGFzc05hbWU9J2xpc3Qtdmlldy1zY3JvbGwnPntzZWN0aW9uc308L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICB7dmlld31cbiAgPC9tYWluPjtcbn07XG4iLCJjb25zdCBnZXRTZWN0aW9uRGF0YSA9IHJlcXVpcmUoJy4vZ2V0U2VjdGlvbkRhdGEnKTtcbmNvbnN0IGV4YW1wbGVzRGF0YSA9IHJlcXVpcmUoJy4vZXhhbXBsZXMtZGF0YS5qc29uJyk7XG5tb2R1bGUuZXhwb3J0cy5leGFtcGxlcyA9IGdldFNlY3Rpb25EYXRhKGV4YW1wbGVzRGF0YSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIGNvbnN0IGxpc3QgPSBkYXRhLm1hcChzID0+IHMuaXRlbXMpLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYiksIFtdKTtcbiAgY29uc3QgbWFwID0gbGlzdC5yZWR1Y2UoKGRpY3QsIGl0ZW0pID0+IHtcbiAgICBpZiAoaXRlbS5uYW1lIGluIGRpY3QpIHRocm93IG5ldyBFcnJvcihgTXVsdGlwbGUgaXRlbXMgd2l0aCB0aGUgc2FtZSBuYW1lOiAke2l0ZW0ubmFtZX1gKTtcbiAgICBkaWN0W2l0ZW0ubmFtZV0gPSBpdGVtO1xuICAgIHJldHVybiBkaWN0O1xuICB9LCB7fSk7XG4gIHJldHVybiB7XG4gICAgZGF0YSxcbiAgICBtYXAsXG4gICAgbGlzdFxuICB9O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzPVtcbiAge1xuICAgIFwidGl0bGVcIjogXCJQcmludHNcIixcbiAgICBcIm5hbWVcIjogXCJwcmludHNcIixcbiAgICBcIml0ZW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiY2FudmFzLTEwLXByaW50XCIsXG4gICAgICAgIFwidGl0bGVcIjogXCIxMCBQUklOVFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJjYW52YXMtZG90LWZsb3dlclwiLFxuICAgICAgICBcInRpdGxlXCI6IFwiRG90IEZsb3dlciBCdXNpbmVzcyBDYXJkXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImNhbnZhcy1nZW5lcmF0aXZlLXNpbGhvdWV0dGVcIixcbiAgICAgICAgXCJ0aXRsZVwiOiBcIkdlbmVyYXRpdmUgU2lsaG91ZXR0ZVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJjYW52YXMtZ2VuZXJhdGl2ZS1hcmNzXCIsXG4gICAgICAgIFwidGl0bGVcIjogXCJHZW5lcmF0aXZlIEFyY3NcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiY2FudmFzLWFic3RyYWN0LXJpc29ncmFwaC1wcmludFwiLFxuICAgICAgICBcInRpdGxlXCI6IFwiQWJzdHJhY3QgUmlzb2dyYXBoIFByaW50XCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRpdGxlXCI6IFwiQW5pbWF0ZWRcIixcbiAgICBcIm5hbWVcIjogXCJhbmltYXRlZFwiLFxuICAgIFwiaXRlbXNcIjogW1xuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhbmltYXRlZC1ncmlkXCIsXG4gICAgICAgIFwidGl0bGVcIjogXCIyRCBHcmlkIEFuaW1hdGlvblwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhbmltYXRlZC1zY3JpYmJsZS1jdXJ2ZXNcIixcbiAgICAgICAgXCJ0aXRsZVwiOiBcIlNjcmliYmxlIEN1cnZlc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhbmltYXRlZC1yZWdsLWRpdGhlci1ibG9iXCIsXG4gICAgICAgIFwidGl0bGVcIjogXCJEaXRoZXIgQmxvYiAoV2ViR0wvUmVnbClcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYW5pbWF0ZWQtcmVnbC1mdWxsc2NyZWVuLXNoYWRlclwiLFxuICAgICAgICBcInRpdGxlXCI6IFwiRnVsbHNjcmVlbiBTaGFkZXIgKFdlYkdML1JlZ2wpXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFuaW1hdGVkLXNpbXBsZS0yZFwiLFxuICAgICAgICBcInRpdGxlXCI6IFwiU2ltcGxlIDJEIEFuaW1hdGlvblwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhbmltYXRlZC1wNVwiLFxuICAgICAgICBcInRpdGxlXCI6IFwiQmFzaWMgcDUuanMgSW50ZWdyYXRpb25cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYW5pbWF0ZWQtdGhyZWUtYmFzaWMtY3ViZVwiLFxuICAgICAgICBcInRpdGxlXCI6IFwiQmFzaWMgVGhyZWUuanMgSW50ZWdyYXRpb25cIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGl0bGVcIjogXCJNZWRpYVwiLFxuICAgIFwibmFtZVwiOiBcIm1lZGlhXCIsXG4gICAgXCJpdGVtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImNhbnZhcy1pbWFnZS1wcm9jZXNzaW5nXCIsXG4gICAgICAgIFwidGl0bGVcIjogXCJJbWFnZSBQcm9jZXNzaW5nXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRpdGxlXCI6IFwiVGVzdHNcIixcbiAgICBcIm5hbWVcIjogXCJ0ZXN0c1wiLFxuICAgIFwiaXRlbXNcIjogW1xuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJjYW52YXMtcGl4ZWwtcHJvY2Vzc2luZ1wiLFxuICAgICAgICBcInRpdGxlXCI6IFwiUGVyLVBpeGVsIFByb2Nlc3NpbmdcIlxuICAgICAgfVxuICAgIF1cbiAgfVxuXVxuIiwiLyoqIEBqc3ggaCAqL1xuY29uc3QgeyBoLCBDb21wb25lbnQgfSA9IHJlcXVpcmUoJ3ByZWFjdCcpO1xuXG4vLyBHcmFiIG91ciBza2V0Y2ggJiBzZXR0aW5nc1xuY29uc3Qgc2tldGNoID0gcmVxdWlyZSgnLi9iYWNrZ3JvdW5kLXNrZXRjaCcpO1xuXG4vLyBUaGUgYWN0dWFsIGNhbnZhcy1za2V0Y2ggbGlicmFyeVxuY29uc3QgY2FudmFzU2tldGNoID0gcmVxdWlyZSgnY2FudmFzLXNrZXRjaCcpO1xuXG4vLyBVdGlsaXR5IGZvciBwcmVhY3QgY2xhc3NOYW1lXG5jb25zdCBjbGFzc25hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIENhbnZhcyBleHRlbmRzIENvbXBvbmVudCB7XG5cbiAgY29tcG9uZW50RGlkTW91bnQgKCkge1xuICAgIC8vIFNpbmNlIHdlIHJlbmRlcigpIHRoZSBjYW52YXMsIGl0IHdpbGwgYmUgdGhlICdiYXNlJyBlbGVtZW50XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5iYXNlO1xuXG4gICAgLy8gU2V0dXAgYSBuZXcgY2FudmFzLXNrZXRjaFxuICAgIHRoaXMuc2tldGNoID0gY2FudmFzU2tldGNoKHNrZXRjaCwgT2JqZWN0LmFzc2lnbih7fSwgc2tldGNoLnNldHRpbmdzLCB7IGNhbnZhcyB9KSk7XG4gICAgdGhpcy5faGFuZGxlQWN0aXZlKHRoaXMucHJvcHMpO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAobmV3UHJvcHMpIHtcbiAgICB0aGlzLl9oYW5kbGVBY3RpdmUobmV3UHJvcHMpO1xuICB9XG5cbiAgX2hhbmRsZUFjdGl2ZSAobmV3UHJvcHMpIHtcbiAgICB0aGlzLnNrZXRjaC50aGVuKHNrZXRjaCA9PiB7XG4gICAgICBpZiAobmV3UHJvcHMuYWN0aXZlICYmICFza2V0Y2gucGxheWluZykgc2tldGNoLnBsYXkoKTtcbiAgICAgIGVsc2Ugc2tldGNoLnN0b3AoKTtcbiAgICB9KTtcbiAgfVxuXG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZSAobmV3UHJvcHMpIHtcbiAgICByZXR1cm4gbmV3UHJvcHMuYWN0aXZlICE9PSB0aGlzLnByb3BzLmFjdGl2ZTtcbiAgfVxuXG4gIHJlbmRlciAoKSB7XG4gICAgY29uc3QgY2xhc3NOYW1lID0gY2xhc3NuYW1lcygnYmFja2dyb3VuZC1jYW52YXMnLCB7XG4gICAgICBhY3RpdmU6IHRoaXMucHJvcHMuYWN0aXZlXG4gICAgfSk7XG4gICAgcmV0dXJuIDxjYW52YXMgY2xhc3NOYW1lPXtjbGFzc05hbWV9IC8+O1xuICB9XG59O1xuIiwiY29uc3QgeyBjbGFtcDAxLCBsaW5zcGFjZSB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vZXhhbXBsZXMvdXRpbC9tYXRoJyk7XG5jb25zdCBQYWludGVyID0gcmVxdWlyZSgnLi4vLi4vLi4vZXhhbXBsZXMvdXRpbC9jYW52YXMtcGFpbnRlcicpO1xuY29uc3QgUmFuZG9tID0gcmVxdWlyZSgnLi4vLi4vLi4vZXhhbXBsZXMvdXRpbC9yYW5kb20nKTtcbmNvbnN0IHR3ZWVuID0gcmVxdWlyZSgnLi4vLi4vLi4vZXhhbXBsZXMvdXRpbC90d2VlbicpO1xuY29uc3QgeyB2ZWMyIH0gPSByZXF1aXJlKCdnbC1tYXRyaXgnKTtcblxuY29uc3Qgc2V0dGluZ3MgPSB7XG4gIGFuaW1hdGU6IHRydWUsXG4gIGhvdGtleXM6IGZhbHNlXG59O1xuXG5jb25zdCBza2V0Y2ggPSAoYXBwKSA9PiB7XG4gIGNvbnN0IGZyaWN0aW9uID0gMC45ODtcbiAgY29uc3QgcGFydGljbGVDb3VudCA9IDMwMDtcbiAgbGV0IG1heENvbm5lY3Rpb25zID0gNTtcbiAgbGV0IGN1cnJlbnRTcGF3bkludGVydmFsID0gMDtcbiAgbGV0IGN1cnJlbnRTcGF3blRpbWUgPSAwO1xuXG4gIC8vIFNpbXBsZSB1dGlsaXR5IGZvciAyRCBsaW5lL2NpcmNsZSBkcmF3aW5nXG4gIGNvbnN0IHBhaW50ZXIgPSBQYWludGVyKGFwcC5jb250ZXh0KTtcblxuICAvLyBDcmVhdGUgYSBsaXN0IG9mICdwYXJ0aWNsZScgb2JqZWN0c1xuICBjb25zdCBwYXJ0aWNsZXMgPSBBcnJheS5mcm9tKG5ldyBBcnJheShwYXJ0aWNsZUNvdW50KSkubWFwKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gV2UnbGwgZmlsbCBpbiB0aGUgcHJvcGVydGllcyBkeW5hbWljYWxseSBpbiBzcGF3bigpXG4gICAgfTtcbiAgfSk7XG5cbiAgY29uc3QgbmV4dFBhcnRpY2xlID0gKCkgPT4ge1xuICAgIHJldHVybiBwYXJ0aWNsZXMuZmluZChwID0+ICFwLmFjdGl2ZSk7XG4gIH07XG5cbiAgY29uc3Qgc3Bhd24gPSAoKSA9PiB7XG4gICAgY29uc3QgcGFydGljbGUgPSBuZXh0UGFydGljbGUoKTtcbiAgICBpZiAoIXBhcnRpY2xlKSByZXR1cm47IC8vIG5vbmUgbGVmdCBpbiBwb29sXG5cbiAgICAvLyBNYXJrIHBhcnRpY2xlIGFzIGFjdGl2ZSwgbm8gbG9uZ2VyIGluIHBvb2xcbiAgICBwYXJ0aWNsZS5hY3RpdmUgPSB0cnVlO1xuXG4gICAgLy8gUmVzZXQgdGltZVxuICAgIHBhcnRpY2xlLnRpbWUgPSAwO1xuXG4gICAgLy8gQ2hvb3NlIGEgbmV3IHBvc2l0aW9uLCB3ZSBhcmUgaW4gMC4uMSBzcGFjZSBoZXJlXG4gICAgY29uc3QgY2VudGVyID0gWyAwLjUsIDAuNSBdO1xuICAgIGNvbnN0IHNjYWxlID0gMC40O1xuICAgIGNvbnN0IG9mZnNldCA9IFJhbmRvbS5nYXVzc2lhbigwLCAwLjA1KTtcbiAgICBwYXJ0aWNsZS5wb3NpdGlvbiA9IHZlYzIuYWRkKFtdLCBSYW5kb20ub25TcXVhcmUoc2NhbGUgKyBvZmZzZXQpLCBjZW50ZXIpO1xuXG4gICAgLy8gU2V0IHNvbWUgbmV3IHJhbmRvbSBwcm9wZXJ0aWVzXG4gICAgcGFydGljbGUuZHVyYXRpb24gPSBSYW5kb20ucmFuZ2UoMywgNSk7XG4gICAgcGFydGljbGUucmFkaXVzID0gUmFuZG9tLnJhbmdlKDEsIDIpO1xuICAgIHBhcnRpY2xlLmNvbm5lY3Rpb25SYWRpdXMgPSBSYW5kb20ucmFuZ2UoMC4xLCAwLjIpO1xuICAgIHBhcnRpY2xlLnNwZWVkID0gMSAvIDEwMDA7XG4gICAgcGFydGljbGUuYW5pbWF0aW9uRHVyYXRpb24gPSAxO1xuXG4gICAgLy8gVXNlIGEgcmFuZG9tIHBvaW50IG9uIHVuaXQgY2lyY2xlIHRvIGdldCBhIHJhbmRvbSB2ZWxvY2l0eSB2ZWN0b3JcbiAgICBwYXJ0aWNsZS52ZWxvY2l0eSA9IFJhbmRvbS5vbkNpcmNsZSgxLCBwYXJ0aWNsZS52ZWxvY2l0eSk7XG5cbiAgICByZXR1cm4gcGFydGljbGU7XG4gIH07XG5cbiAgY29uc3Qgc3Bhd25NdWx0aXBsZSA9ICgpID0+IHtcbiAgICBjb25zdCBjb3VudCA9IFJhbmRvbS5yYW5nZUZsb29yKDEsIDYpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykgc3Bhd24oKTtcbiAgfTtcblxuICBjb25zdCB0aWNrID0gKHsgZGVsdGFUaW1lLCB3aWR0aCwgaGVpZ2h0IH0pID0+IHtcbiAgICBjdXJyZW50U3Bhd25UaW1lICs9IGRlbHRhVGltZTtcbiAgICBpZiAoY3VycmVudFNwYXduVGltZSA+IGN1cnJlbnRTcGF3bkludGVydmFsKSB7XG4gICAgICBjdXJyZW50U3Bhd25UaW1lID0gMDtcbiAgICAgIGN1cnJlbnRTcGF3bkludGVydmFsID0gUmFuZG9tLnJhbmdlKDAuMjUsIDAuMzUpO1xuICAgICAgc3Bhd25NdWx0aXBsZSgpO1xuICAgIH1cblxuICAgIHBhcnRpY2xlcy5mb3JFYWNoKHBhcnRpY2xlID0+IHtcbiAgICAgIGlmICghcGFydGljbGUuYWN0aXZlKSByZXR1cm47IC8vIGlnbm9yZSBkZWFkL3VudXNlZCBwYXJ0aWNsZXNcblxuICAgICAgcGFydGljbGUudGltZSArPSBkZWx0YVRpbWU7XG4gICAgICBpZiAocGFydGljbGUudGltZSA+IHBhcnRpY2xlLmR1cmF0aW9uKSB7XG4gICAgICAgIHBhcnRpY2xlLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIE1vdmUgYWxvbmcgdmVsb2NpdHlcbiAgICAgIHZlYzIuc2NhbGVBbmRBZGQocGFydGljbGUucG9zaXRpb24sIHBhcnRpY2xlLnBvc2l0aW9uLCBwYXJ0aWNsZS52ZWxvY2l0eSwgcGFydGljbGUuc3BlZWQpO1xuICAgICAgdmVjMi5zY2FsZShwYXJ0aWNsZS52ZWxvY2l0eSwgcGFydGljbGUudmVsb2NpdHksIGZyaWN0aW9uKTtcbiAgICB9KTtcbiAgfTtcblxuICBjb25zdCByZW5kZXIgPSAoeyBjb250ZXh0LCBkZWx0YVRpbWUsIHdpZHRoLCBoZWlnaHQgfSkgPT4ge1xuICAgIHBhaW50ZXIuY2xlYXIoeyBmaWxsOiAnd2hpdGUnLCB3aWR0aCwgaGVpZ2h0IH0pO1xuXG4gICAgY29udGV4dC5zYXZlKCk7XG5cbiAgICAvLyBVcGRhdGUgJiBkcmF3IGVhY2ggcGFydGljbGVcbiAgICBwYXJ0aWNsZXMuZm9yRWFjaChwYXJ0aWNsZSA9PiB7XG4gICAgICAvLyBTa2lwIGluYWN0aXZlIHBhcnRpY2xlc1xuICAgICAgaWYgKCFwYXJ0aWNsZS5hY3RpdmUpIHJldHVybjtcblxuICAgICAgY29uc3Qgc2l6ZSA9IHBhcnRpY2xlLnJhZGl1cyAqIHR3ZWVuKHtcbiAgICAgICAgdGltZTogcGFydGljbGUudGltZSxcbiAgICAgICAgZWFzZTogJ3F1YWRPdXQnLFxuICAgICAgICBlZGdlOiBwYXJ0aWNsZS5hbmltYXRpb25EdXJhdGlvbixcbiAgICAgICAgZHVyYXRpb246IHBhcnRpY2xlLmR1cmF0aW9uXG4gICAgICB9KTtcblxuICAgICAgLy8gUGFpbnQgY2lyY2xlXG4gICAgICBwYWludGVyLmNpcmNsZSh7XG4gICAgICAgIGFscGhhOiAwLjIsXG4gICAgICAgIHBvc2l0aW9uOiBbIHBhcnRpY2xlLnBvc2l0aW9uWzBdICogd2lkdGgsIHBhcnRpY2xlLnBvc2l0aW9uWzFdICogaGVpZ2h0IF0sXG4gICAgICAgIHJhZGl1czogc2l6ZVxuICAgICAgfSk7XG5cbiAgICAgIC8vIFBhaW50IGNvbm5lY3Rpb25zXG4gICAgICBjb25zdCBjb25uZWN0aW9uUmFkaXVzID0gcGFydGljbGUuY29ubmVjdGlvblJhZGl1cztcbiAgICAgIGZvciAobGV0IGkgPSAwLCBjID0gMDsgaSA8IHBhcnRpY2xlcy5sZW5ndGggJiYgYyA8IG1heENvbm5lY3Rpb25zOyBpKyspIHtcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBwYXJ0aWNsZXNbaV07XG4gICAgICAgIGlmIChvdGhlciA9PT0gcGFydGljbGUgfHwgIW90aGVyLmFjdGl2ZSkgY29udGludWU7IC8vIHNraXAgc2VsZlxuICAgICAgICBjb25zdCBkaXN0ID0gdmVjMi5kaXN0YW5jZShvdGhlci5wb3NpdGlvbiwgcGFydGljbGUucG9zaXRpb24pO1xuICAgICAgICBpZiAoZGlzdCA8PSBjb25uZWN0aW9uUmFkaXVzKSB7XG4gICAgICAgICAgY29uc3QgZGlzdFN0ciA9IE1hdGguc2luKE1hdGguUEkgKiBjbGFtcDAxKGRpc3QgLyBjb25uZWN0aW9uUmFkaXVzKSk7XG4gICAgICAgICAgLy8gTmVlZCB0byBtYXAgZnJvbSAwLi4xIHRvIDAuLnNjcmVlblNpemVcbiAgICAgICAgICBjb25zdCBwb3NpdGlvbnMgPSBbIHBhcnRpY2xlLnBvc2l0aW9uLCBvdGhlci5wb3NpdGlvbiBdLm1hcChwID0+IChcbiAgICAgICAgICAgIFsgcFswXSAqIHdpZHRoLCBwWzFdICogaGVpZ2h0IF1cbiAgICAgICAgICApKTtcbiAgICAgICAgICBwYWludGVyLnBvbHlsaW5lKHBvc2l0aW9ucywge1xuICAgICAgICAgICAgYWxwaGE6IDAuMiAqIGRpc3RTdHIsXG4gICAgICAgICAgICBzdHJva2U6ICdibGFjaycsXG4gICAgICAgICAgICBsaW5lV2lkdGg6IDAuMjUgKiBkaXN0U3RyXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgcmVuZGVyLFxuICAgIHRpY2tcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc2tldGNoO1xubW9kdWxlLmV4cG9ydHMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuTGluayA9IGV4cG9ydHMuTWF0Y2ggPSB1bmRlZmluZWQ7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfcHJlYWN0ID0gcmVxdWlyZSgncHJlYWN0Jyk7XG5cbnZhciBfcHJlYWN0Um91dGVyID0gcmVxdWlyZSgncHJlYWN0LXJvdXRlcicpO1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIE1hdGNoID0gZXhwb3J0cy5NYXRjaCA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG5cdF9pbmhlcml0cyhNYXRjaCwgX0NvbXBvbmVudCk7XG5cblx0ZnVuY3Rpb24gTWF0Y2goKSB7XG5cdFx0dmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYXRjaCk7XG5cblx0XHRmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuXHRcdFx0YXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcblx0XHR9XG5cblx0XHRyZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbC5hcHBseShfQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudXBkYXRlID0gZnVuY3Rpb24gKHVybCkge1xuXHRcdFx0X3RoaXMubmV4dFVybCA9IHVybDtcblx0XHRcdF90aGlzLnNldFN0YXRlKHt9KTtcblx0XHR9LCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcblx0fVxuXG5cdE1hdGNoLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuXHRcdF9wcmVhY3RSb3V0ZXIuc3Vic2NyaWJlcnMucHVzaCh0aGlzLnVwZGF0ZSk7XG5cdH07XG5cblx0TWF0Y2gucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG5cdFx0X3ByZWFjdFJvdXRlci5zdWJzY3JpYmVycy5zcGxpY2UoX3ByZWFjdFJvdXRlci5zdWJzY3JpYmVycy5pbmRleE9mKHRoaXMudXBkYXRlKSA+Pj4gMCwgMSk7XG5cdH07XG5cblx0TWF0Y2gucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihwcm9wcykge1xuXHRcdHZhciB1cmwgPSB0aGlzLm5leHRVcmwgfHwgKDAsIF9wcmVhY3RSb3V0ZXIuZ2V0Q3VycmVudFVybCkoKSxcblx0XHQgICAgcGF0aCA9IHVybC5yZXBsYWNlKC9cXD8uKyQvLCAnJyk7XG5cdFx0dGhpcy5uZXh0VXJsID0gbnVsbDtcblx0XHRyZXR1cm4gcHJvcHMuY2hpbGRyZW5bMF0gJiYgcHJvcHMuY2hpbGRyZW5bMF0oe1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHRwYXRoOiBwYXRoLFxuXHRcdFx0bWF0Y2hlczogcGF0aCA9PT0gcHJvcHMucGF0aFxuXHRcdH0pO1xuXHR9O1xuXG5cdHJldHVybiBNYXRjaDtcbn0oX3ByZWFjdC5Db21wb25lbnQpO1xuXG52YXIgTGluayA9IGZ1bmN0aW9uIExpbmsoX3JlZikge1xuXHR2YXIgYWN0aXZlQ2xhc3NOYW1lID0gX3JlZi5hY3RpdmVDbGFzc05hbWUsXG5cdCAgICBwYXRoID0gX3JlZi5wYXRoLFxuXHQgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWydhY3RpdmVDbGFzc05hbWUnLCAncGF0aCddKTtcblxuXHRyZXR1cm4gKDAsIF9wcmVhY3QuaCkoXG5cdFx0TWF0Y2gsXG5cdFx0eyBwYXRoOiBwYXRoIHx8IHByb3BzLmhyZWYgfSxcblx0XHRmdW5jdGlvbiAoX3JlZjIpIHtcblx0XHRcdHZhciBtYXRjaGVzID0gX3JlZjIubWF0Y2hlcztcblx0XHRcdHJldHVybiAoMCwgX3ByZWFjdC5oKShfcHJlYWN0Um91dGVyLkxpbmssIF9leHRlbmRzKHt9LCBwcm9wcywgeyAnY2xhc3MnOiBbcHJvcHMuY2xhc3MgfHwgcHJvcHMuY2xhc3NOYW1lLCBtYXRjaGVzICYmIGFjdGl2ZUNsYXNzTmFtZV0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJyAnKSB9KSk7XG5cdFx0fVxuXHQpO1xufTtcblxuZXhwb3J0cy5MaW5rID0gTGluaztcbmV4cG9ydHMuZGVmYXVsdCA9IE1hdGNoO1xuXG5NYXRjaC5MaW5rID0gTGluaztcbiIsIiFmdW5jdGlvbih0LGUpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPWUocmVxdWlyZShcInByZWFjdFwiKSk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXCJwcmVhY3RcIl0sZSk6dC5wcmVhY3RSb3V0ZXI9ZSh0LnByZWFjdCl9KHRoaXMsZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0LGUpe2Zvcih2YXIgbiBpbiBlKXRbbl09ZVtuXTtyZXR1cm4gdH1mdW5jdGlvbiBuKHQsZSxuKXt2YXIgcixvPS8oPzpcXD8oW14jXSopKT8oIy4qKT8kLyx1PXQubWF0Y2gobyksYT17fTtpZih1JiZ1WzFdKWZvcih2YXIgcD11WzFdLnNwbGl0KFwiJlwiKSxjPTA7YzxwLmxlbmd0aDtjKyspe3ZhciBmPXBbY10uc3BsaXQoXCI9XCIpO2FbZGVjb2RlVVJJQ29tcG9uZW50KGZbMF0pXT1kZWNvZGVVUklDb21wb25lbnQoZi5zbGljZSgxKS5qb2luKFwiPVwiKSl9dD1pKHQucmVwbGFjZShvLFwiXCIpKSxlPWkoZXx8XCJcIik7Zm9yKHZhciBsPU1hdGgubWF4KHQubGVuZ3RoLGUubGVuZ3RoKSxzPTA7czxsO3MrKylpZihlW3NdJiZcIjpcIj09PWVbc10uY2hhckF0KDApKXt2YXIgaD1lW3NdLnJlcGxhY2UoLyheXFw6fFsrKj9dKyQpL2csXCJcIiksZD0oZVtzXS5tYXRjaCgvWysqP10rJC8pfHxDKVswXXx8XCJcIixnPX5kLmluZGV4T2YoXCIrXCIpLG09fmQuaW5kZXhPZihcIipcIikseT10W3NdfHxcIlwiO2lmKCF5JiYhbSYmKGQuaW5kZXhPZihcIj9cIik8MHx8Zykpe3I9ITE7YnJlYWt9aWYoYVtoXT1kZWNvZGVVUklDb21wb25lbnQoeSksZ3x8bSl7YVtoXT10LnNsaWNlKHMpLm1hcChkZWNvZGVVUklDb21wb25lbnQpLmpvaW4oXCIvXCIpO2JyZWFrfX1lbHNlIGlmKGVbc10hPT10W3NdKXtyPSExO2JyZWFrfXJldHVybighMD09PW4uZGVmYXVsdHx8ITEhPT1yKSYmYX1mdW5jdGlvbiByKHQsZSl7cmV0dXJuIHQucmFuazxlLnJhbms/MTp0LnJhbms+ZS5yYW5rPy0xOnQuaW5kZXgtZS5pbmRleH1mdW5jdGlvbiBvKHQsZSl7cmV0dXJuIHQuaW5kZXg9ZSx0LnJhbms9cCh0KSx0LmF0dHJpYnV0ZXN9ZnVuY3Rpb24gaSh0KXtyZXR1cm4gdC5yZXBsYWNlKC8oXlxcLyt8XFwvKyQpL2csXCJcIikuc3BsaXQoXCIvXCIpfWZ1bmN0aW9uIHUodCl7cmV0dXJuXCI6XCI9PXQuY2hhckF0KDApPzErXCIqKz9cIi5pbmRleE9mKHQuY2hhckF0KHQubGVuZ3RoLTEpKXx8NDo1fWZ1bmN0aW9uIGEodCl7cmV0dXJuIGkodCkubWFwKHUpLmpvaW4oXCJcIil9ZnVuY3Rpb24gcCh0KXtyZXR1cm4gdC5hdHRyaWJ1dGVzLmRlZmF1bHQ/MDphKHQuYXR0cmlidXRlcy5wYXRoKX1mdW5jdGlvbiBjKHQpe3JldHVybiBudWxsIT10Ll9fcHJlYWN0YXR0cl98fFwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJm51bGwhPXRbU3ltYm9sLmZvcihcInByZWFjdGF0dHJcIildfWZ1bmN0aW9uIGYodCxlKXt2b2lkIDA9PT1lJiYoZT1cInB1c2hcIiksUiYmUltlXT9SW2VdKHQpOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBoaXN0b3J5JiZoaXN0b3J5W2UrXCJTdGF0ZVwiXSYmaGlzdG9yeVtlK1wiU3RhdGVcIl0obnVsbCxudWxsLHQpfWZ1bmN0aW9uIGwoKXt2YXIgdDtyZXR1cm4gdD1SJiZSLmxvY2F0aW9uP1IubG9jYXRpb246UiYmUi5nZXRDdXJyZW50TG9jYXRpb24/Ui5nZXRDdXJyZW50TG9jYXRpb24oKTpcInVuZGVmaW5lZFwiIT10eXBlb2YgbG9jYXRpb24/bG9jYXRpb246eCxcIlwiKyh0LnBhdGhuYW1lfHxcIlwiKSsodC5zZWFyY2h8fFwiXCIpfWZ1bmN0aW9uIHModCxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9ITEpLFwic3RyaW5nXCIhPXR5cGVvZiB0JiZ0LnVybCYmKGU9dC5yZXBsYWNlLHQ9dC51cmwpLGgodCkmJmYodCxlP1wicmVwbGFjZVwiOlwicHVzaFwiKSxkKHQpfWZ1bmN0aW9uIGgodCl7Zm9yKHZhciBlPVUubGVuZ3RoO2UtLTspaWYoVVtlXS5jYW5Sb3V0ZSh0KSlyZXR1cm4hMDtyZXR1cm4hMX1mdW5jdGlvbiBkKHQpe2Zvcih2YXIgZT0hMSxuPTA7bjxVLmxlbmd0aDtuKyspITA9PT1VW25dLnJvdXRlVG8odCkmJihlPSEwKTtmb3IodmFyIHI9ay5sZW5ndGg7ci0tOylrW3JdKHQpO3JldHVybiBlfWZ1bmN0aW9uIGcodCl7aWYodCYmdC5nZXRBdHRyaWJ1dGUpe3ZhciBlPXQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSxuPXQuZ2V0QXR0cmlidXRlKFwidGFyZ2V0XCIpO2lmKGUmJmUubWF0Y2goL15cXC8vZykmJighbnx8bi5tYXRjaCgvXl8/c2VsZiQvaSkpKXJldHVybiBzKGUpfX1mdW5jdGlvbiBtKHQpe2lmKDA9PXQuYnV0dG9uKXJldHVybiBnKHQuY3VycmVudFRhcmdldHx8dC50YXJnZXR8fHRoaXMpLHkodCl9ZnVuY3Rpb24geSh0KXtyZXR1cm4gdCYmKHQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uJiZ0LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLHQuc3RvcFByb3BhZ2F0aW9uJiZ0LnN0b3BQcm9wYWdhdGlvbigpLHQucHJldmVudERlZmF1bHQoKSksITF9ZnVuY3Rpb24gdih0KXtpZighKHQuY3RybEtleXx8dC5tZXRhS2V5fHx0LmFsdEtleXx8dC5zaGlmdEtleXx8MCE9PXQuYnV0dG9uKSl7dmFyIGU9dC50YXJnZXQ7ZG97aWYoXCJBXCI9PT0oZS5ub2RlTmFtZStcIlwiKS50b1VwcGVyQ2FzZSgpJiZlLmdldEF0dHJpYnV0ZShcImhyZWZcIikmJmMoZSkpe2lmKGUuaGFzQXR0cmlidXRlKFwibmF0aXZlXCIpKXJldHVybjtpZihnKGUpKXJldHVybiB5KHQpfX13aGlsZShlPWUucGFyZW50Tm9kZSl9fWZ1bmN0aW9uIGIoKXtffHwoXCJmdW5jdGlvblwiPT10eXBlb2YgYWRkRXZlbnRMaXN0ZW5lciYmKFJ8fGFkZEV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLGZ1bmN0aW9uKCl7ZChsKCkpfSksYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsdikpLF89ITApfXZhciBDPXt9LFI9bnVsbCxVPVtdLGs9W10seD17fSxfPSExLEE9ZnVuY3Rpb24oaSl7ZnVuY3Rpb24gdSh0KXtpLmNhbGwodGhpcyx0KSx0Lmhpc3RvcnkmJihSPXQuaGlzdG9yeSksdGhpcy5zdGF0ZT17dXJsOnQudXJsfHxsKCl9LGIoKX1yZXR1cm4gaSYmKHUuX19wcm90b19fPWkpLHUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoaSYmaS5wcm90b3R5cGUpLHUucHJvdG90eXBlLmNvbnN0cnVjdG9yPXUsdS5wcm90b3R5cGUuc2hvdWxkQ29tcG9uZW50VXBkYXRlPWZ1bmN0aW9uKHQpe3JldHVybiEwIT09dC5zdGF0aWN8fCh0LnVybCE9PXRoaXMucHJvcHMudXJsfHx0Lm9uQ2hhbmdlIT09dGhpcy5wcm9wcy5vbkNoYW5nZSl9LHUucHJvdG90eXBlLmNhblJvdXRlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmdldE1hdGNoaW5nQ2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbix0LCExKS5sZW5ndGg+MH0sdS5wcm90b3R5cGUucm91dGVUbz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fZGlkUm91dGU9ITEsdGhpcy5zZXRTdGF0ZSh7dXJsOnR9KSx0aGlzLnVwZGF0aW5nP3RoaXMuY2FuUm91dGUodCk6KHRoaXMuZm9yY2VVcGRhdGUoKSx0aGlzLl9kaWRSb3V0ZSl9LHUucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudD1mdW5jdGlvbigpe1UucHVzaCh0aGlzKSx0aGlzLnVwZGF0aW5nPSEwfSx1LnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudD1mdW5jdGlvbigpe3ZhciB0PXRoaXM7UiYmKHRoaXMudW5saXN0ZW49Ui5saXN0ZW4oZnVuY3Rpb24oZSl7dC5yb3V0ZVRvKFwiXCIrKGUucGF0aG5hbWV8fFwiXCIpKyhlLnNlYXJjaHx8XCJcIikpfSkpLHRoaXMudXBkYXRpbmc9ITF9LHUucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50PWZ1bmN0aW9uKCl7XCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy51bmxpc3RlbiYmdGhpcy51bmxpc3RlbigpLFUuc3BsaWNlKFUuaW5kZXhPZih0aGlzKSwxKX0sdS5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVwZGF0ZT1mdW5jdGlvbigpe3RoaXMudXBkYXRpbmc9ITB9LHUucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZT1mdW5jdGlvbigpe3RoaXMudXBkYXRpbmc9ITF9LHUucHJvdG90eXBlLmdldE1hdGNoaW5nQ2hpbGRyZW49ZnVuY3Rpb24oaSx1LGEpe3JldHVybiBpLmZpbHRlcihvKS5zb3J0KHIpLm1hcChmdW5jdGlvbihyKXt2YXIgbz1uKHUsci5hdHRyaWJ1dGVzLnBhdGgsci5hdHRyaWJ1dGVzKTtpZihvKXtpZighMSE9PWEpe3ZhciBpPXt1cmw6dSxtYXRjaGVzOm99O3JldHVybiBlKGksbyksZGVsZXRlIGkucmVmLGRlbGV0ZSBpLmtleSx0LmNsb25lRWxlbWVudChyLGkpfXJldHVybiByfX0pLmZpbHRlcihCb29sZWFuKX0sdS5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKHQsZSl7dmFyIG49dC5jaGlsZHJlbixyPXQub25DaGFuZ2Usbz1lLnVybCxpPXRoaXMuZ2V0TWF0Y2hpbmdDaGlsZHJlbihuLG8sITApLHU9aVswXXx8bnVsbDt0aGlzLl9kaWRSb3V0ZT0hIXU7dmFyIGE9dGhpcy5wcmV2aW91c1VybDtyZXR1cm4gbyE9PWEmJih0aGlzLnByZXZpb3VzVXJsPW8sXCJmdW5jdGlvblwiPT10eXBlb2YgciYmcih7cm91dGVyOnRoaXMsdXJsOm8scHJldmlvdXM6YSxhY3RpdmU6aSxjdXJyZW50OnV9KSksdX0sdX0odC5Db21wb25lbnQpLEk9ZnVuY3Rpb24obil7cmV0dXJuIHQuaChcImFcIixlKHtvbkNsaWNrOm19LG4pKX0sTD1mdW5jdGlvbihlKXtyZXR1cm4gdC5oKGUuY29tcG9uZW50LGUpfTtyZXR1cm4gQS5zdWJzY3JpYmVycz1rLEEuZ2V0Q3VycmVudFVybD1sLEEucm91dGU9cyxBLlJvdXRlcj1BLEEuUm91dGU9TCxBLkxpbms9SSxBfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmVhY3Qtcm91dGVyLmpzLm1hcFxuIiwiIWZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBmdW5jdGlvbiBWTm9kZSgpIHt9XG4gICAgZnVuY3Rpb24gaChub2RlTmFtZSwgYXR0cmlidXRlcykge1xuICAgICAgICB2YXIgbGFzdFNpbXBsZSwgY2hpbGQsIHNpbXBsZSwgaSwgY2hpbGRyZW4gPSBFTVBUWV9DSElMRFJFTjtcbiAgICAgICAgZm9yIChpID0gYXJndW1lbnRzLmxlbmd0aDsgaS0tID4gMjsgKSBzdGFjay5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzICYmIG51bGwgIT0gYXR0cmlidXRlcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKCFzdGFjay5sZW5ndGgpIHN0YWNrLnB1c2goYXR0cmlidXRlcy5jaGlsZHJlbik7XG4gICAgICAgICAgICBkZWxldGUgYXR0cmlidXRlcy5jaGlsZHJlbjtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSBpZiAoKGNoaWxkID0gc3RhY2sucG9wKCkpICYmIHZvaWQgMCAhPT0gY2hpbGQucG9wKSBmb3IgKGkgPSBjaGlsZC5sZW5ndGg7IGktLTsgKSBzdGFjay5wdXNoKGNoaWxkW2ldKTsgZWxzZSB7XG4gICAgICAgICAgICBpZiAoJ2Jvb2xlYW4nID09IHR5cGVvZiBjaGlsZCkgY2hpbGQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHNpbXBsZSA9ICdmdW5jdGlvbicgIT0gdHlwZW9mIG5vZGVOYW1lKSBpZiAobnVsbCA9PSBjaGlsZCkgY2hpbGQgPSAnJzsgZWxzZSBpZiAoJ251bWJlcicgPT0gdHlwZW9mIGNoaWxkKSBjaGlsZCA9IFN0cmluZyhjaGlsZCk7IGVsc2UgaWYgKCdzdHJpbmcnICE9IHR5cGVvZiBjaGlsZCkgc2ltcGxlID0gITE7XG4gICAgICAgICAgICBpZiAoc2ltcGxlICYmIGxhc3RTaW1wbGUpIGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdICs9IGNoaWxkOyBlbHNlIGlmIChjaGlsZHJlbiA9PT0gRU1QVFlfQ0hJTERSRU4pIGNoaWxkcmVuID0gWyBjaGlsZCBdOyBlbHNlIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgbGFzdFNpbXBsZSA9IHNpbXBsZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcCA9IG5ldyBWTm9kZSgpO1xuICAgICAgICBwLm5vZGVOYW1lID0gbm9kZU5hbWU7XG4gICAgICAgIHAuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgcC5hdHRyaWJ1dGVzID0gbnVsbCA9PSBhdHRyaWJ1dGVzID8gdm9pZCAwIDogYXR0cmlidXRlcztcbiAgICAgICAgcC5rZXkgPSBudWxsID09IGF0dHJpYnV0ZXMgPyB2b2lkIDAgOiBhdHRyaWJ1dGVzLmtleTtcbiAgICAgICAgaWYgKHZvaWQgMCAhPT0gb3B0aW9ucy52bm9kZSkgb3B0aW9ucy52bm9kZShwKTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGV4dGVuZChvYmosIHByb3BzKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gcHJvcHMpIG9ialtpXSA9IHByb3BzW2ldO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbG9uZUVsZW1lbnQodm5vZGUsIHByb3BzKSB7XG4gICAgICAgIHJldHVybiBoKHZub2RlLm5vZGVOYW1lLCBleHRlbmQoZXh0ZW5kKHt9LCB2bm9kZS5hdHRyaWJ1dGVzKSwgcHJvcHMpLCBhcmd1bWVudHMubGVuZ3RoID4gMiA/IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSA6IHZub2RlLmNoaWxkcmVuKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5xdWV1ZVJlbmRlcihjb21wb25lbnQpIHtcbiAgICAgICAgaWYgKCFjb21wb25lbnQuX19kICYmIChjb21wb25lbnQuX19kID0gITApICYmIDEgPT0gaXRlbXMucHVzaChjb21wb25lbnQpKSAob3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZyB8fCBkZWZlcikocmVyZW5kZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXJlbmRlcigpIHtcbiAgICAgICAgdmFyIHAsIGxpc3QgPSBpdGVtcztcbiAgICAgICAgaXRlbXMgPSBbXTtcbiAgICAgICAgd2hpbGUgKHAgPSBsaXN0LnBvcCgpKSBpZiAocC5fX2QpIHJlbmRlckNvbXBvbmVudChwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNTYW1lTm9kZVR5cGUobm9kZSwgdm5vZGUsIGh5ZHJhdGluZykge1xuICAgICAgICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIHZub2RlIHx8ICdudW1iZXInID09IHR5cGVvZiB2bm9kZSkgcmV0dXJuIHZvaWQgMCAhPT0gbm9kZS5zcGxpdFRleHQ7XG4gICAgICAgIGlmICgnc3RyaW5nJyA9PSB0eXBlb2Ygdm5vZGUubm9kZU5hbWUpIHJldHVybiAhbm9kZS5fY29tcG9uZW50Q29uc3RydWN0b3IgJiYgaXNOYW1lZE5vZGUobm9kZSwgdm5vZGUubm9kZU5hbWUpOyBlbHNlIHJldHVybiBoeWRyYXRpbmcgfHwgbm9kZS5fY29tcG9uZW50Q29uc3RydWN0b3IgPT09IHZub2RlLm5vZGVOYW1lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc05hbWVkTm9kZShub2RlLCBub2RlTmFtZSkge1xuICAgICAgICByZXR1cm4gbm9kZS5fX24gPT09IG5vZGVOYW1lIHx8IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Tm9kZVByb3BzKHZub2RlKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IGV4dGVuZCh7fSwgdm5vZGUuYXR0cmlidXRlcyk7XG4gICAgICAgIHByb3BzLmNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB2bm9kZS5ub2RlTmFtZS5kZWZhdWx0UHJvcHM7XG4gICAgICAgIGlmICh2b2lkIDAgIT09IGRlZmF1bHRQcm9wcykgZm9yICh2YXIgaSBpbiBkZWZhdWx0UHJvcHMpIGlmICh2b2lkIDAgPT09IHByb3BzW2ldKSBwcm9wc1tpXSA9IGRlZmF1bHRQcm9wc1tpXTtcbiAgICAgICAgcmV0dXJuIHByb3BzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVOb2RlKG5vZGVOYW1lLCBpc1N2Zykge1xuICAgICAgICB2YXIgbm9kZSA9IGlzU3ZnID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIG5vZGVOYW1lKSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobm9kZU5hbWUpO1xuICAgICAgICBub2RlLl9fbiA9IG5vZGVOYW1lO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTm9kZShub2RlKSB7XG4gICAgICAgIHZhciBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAocGFyZW50Tm9kZSkgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0QWNjZXNzb3Iobm9kZSwgbmFtZSwgb2xkLCB2YWx1ZSwgaXNTdmcpIHtcbiAgICAgICAgaWYgKCdjbGFzc05hbWUnID09PSBuYW1lKSBuYW1lID0gJ2NsYXNzJztcbiAgICAgICAgaWYgKCdrZXknID09PSBuYW1lKSA7IGVsc2UgaWYgKCdyZWYnID09PSBuYW1lKSB7XG4gICAgICAgICAgICBpZiAob2xkKSBvbGQobnVsbCk7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHZhbHVlKG5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKCdjbGFzcycgPT09IG5hbWUgJiYgIWlzU3ZnKSBub2RlLmNsYXNzTmFtZSA9IHZhbHVlIHx8ICcnOyBlbHNlIGlmICgnc3R5bGUnID09PSBuYW1lKSB7XG4gICAgICAgICAgICBpZiAoIXZhbHVlIHx8ICdzdHJpbmcnID09IHR5cGVvZiB2YWx1ZSB8fCAnc3RyaW5nJyA9PSB0eXBlb2Ygb2xkKSBub2RlLnN0eWxlLmNzc1RleHQgPSB2YWx1ZSB8fCAnJztcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiAnb2JqZWN0JyA9PSB0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoJ3N0cmluZycgIT0gdHlwZW9mIG9sZCkgZm9yICh2YXIgaSBpbiBvbGQpIGlmICghKGkgaW4gdmFsdWUpKSBub2RlLnN0eWxlW2ldID0gJyc7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB2YWx1ZSkgbm9kZS5zdHlsZVtpXSA9ICdudW1iZXInID09IHR5cGVvZiB2YWx1ZVtpXSAmJiAhMSA9PT0gSVNfTk9OX0RJTUVOU0lPTkFMLnRlc3QoaSkgPyB2YWx1ZVtpXSArICdweCcgOiB2YWx1ZVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICgnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnID09PSBuYW1lKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUpIG5vZGUuaW5uZXJIVE1MID0gdmFsdWUuX19odG1sIHx8ICcnO1xuICAgICAgICB9IGVsc2UgaWYgKCdvJyA9PSBuYW1lWzBdICYmICduJyA9PSBuYW1lWzFdKSB7XG4gICAgICAgICAgICB2YXIgdXNlQ2FwdHVyZSA9IG5hbWUgIT09IChuYW1lID0gbmFtZS5yZXBsYWNlKC9DYXB0dXJlJC8sICcnKSk7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpLnN1YnN0cmluZygyKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICghb2xkKSBub2RlLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZXZlbnRQcm94eSwgdXNlQ2FwdHVyZSk7XG4gICAgICAgICAgICB9IGVsc2Ugbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGV2ZW50UHJveHksIHVzZUNhcHR1cmUpO1xuICAgICAgICAgICAgKG5vZGUuX19sIHx8IChub2RlLl9fbCA9IHt9KSlbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICgnbGlzdCcgIT09IG5hbWUgJiYgJ3R5cGUnICE9PSBuYW1lICYmICFpc1N2ZyAmJiBuYW1lIGluIG5vZGUpIHtcbiAgICAgICAgICAgIHNldFByb3BlcnR5KG5vZGUsIG5hbWUsIG51bGwgPT0gdmFsdWUgPyAnJyA6IHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChudWxsID09IHZhbHVlIHx8ICExID09PSB2YWx1ZSkgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbnMgPSBpc1N2ZyAmJiBuYW1lICE9PSAobmFtZSA9IG5hbWUucmVwbGFjZSgvXnhsaW5rOj8vLCAnJykpO1xuICAgICAgICAgICAgaWYgKG51bGwgPT0gdmFsdWUgfHwgITEgPT09IHZhbHVlKSBpZiAobnMpIG5vZGUucmVtb3ZlQXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCBuYW1lLnRvTG93ZXJDYXNlKCkpOyBlbHNlIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpOyBlbHNlIGlmICgnZnVuY3Rpb24nICE9IHR5cGVvZiB2YWx1ZSkgaWYgKG5zKSBub2RlLnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgbmFtZS50b0xvd2VyQ2FzZSgpLCB2YWx1ZSk7IGVsc2Ugbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldFByb3BlcnR5KG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBub2RlW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGV2ZW50UHJveHkoZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2xbZS50eXBlXShvcHRpb25zLmV2ZW50ICYmIG9wdGlvbnMuZXZlbnQoZSkgfHwgZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoTW91bnRzKCkge1xuICAgICAgICB2YXIgYztcbiAgICAgICAgd2hpbGUgKGMgPSBtb3VudHMucG9wKCkpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFmdGVyTW91bnQpIG9wdGlvbnMuYWZ0ZXJNb3VudChjKTtcbiAgICAgICAgICAgIGlmIChjLmNvbXBvbmVudERpZE1vdW50KSBjLmNvbXBvbmVudERpZE1vdW50KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGlmZihkb20sIHZub2RlLCBjb250ZXh0LCBtb3VudEFsbCwgcGFyZW50LCBjb21wb25lbnRSb290KSB7XG4gICAgICAgIGlmICghZGlmZkxldmVsKyspIHtcbiAgICAgICAgICAgIGlzU3ZnTW9kZSA9IG51bGwgIT0gcGFyZW50ICYmIHZvaWQgMCAhPT0gcGFyZW50Lm93bmVyU1ZHRWxlbWVudDtcbiAgICAgICAgICAgIGh5ZHJhdGluZyA9IG51bGwgIT0gZG9tICYmICEoJ19fcHJlYWN0YXR0cl8nIGluIGRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJldCA9IGlkaWZmKGRvbSwgdm5vZGUsIGNvbnRleHQsIG1vdW50QWxsLCBjb21wb25lbnRSb290KTtcbiAgICAgICAgaWYgKHBhcmVudCAmJiByZXQucGFyZW50Tm9kZSAhPT0gcGFyZW50KSBwYXJlbnQuYXBwZW5kQ2hpbGQocmV0KTtcbiAgICAgICAgaWYgKCEtLWRpZmZMZXZlbCkge1xuICAgICAgICAgICAgaHlkcmF0aW5nID0gITE7XG4gICAgICAgICAgICBpZiAoIWNvbXBvbmVudFJvb3QpIGZsdXNoTW91bnRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaWRpZmYoZG9tLCB2bm9kZSwgY29udGV4dCwgbW91bnRBbGwsIGNvbXBvbmVudFJvb3QpIHtcbiAgICAgICAgdmFyIG91dCA9IGRvbSwgcHJldlN2Z01vZGUgPSBpc1N2Z01vZGU7XG4gICAgICAgIGlmIChudWxsID09IHZub2RlIHx8ICdib29sZWFuJyA9PSB0eXBlb2Ygdm5vZGUpIHZub2RlID0gJyc7XG4gICAgICAgIGlmICgnc3RyaW5nJyA9PSB0eXBlb2Ygdm5vZGUgfHwgJ251bWJlcicgPT0gdHlwZW9mIHZub2RlKSB7XG4gICAgICAgICAgICBpZiAoZG9tICYmIHZvaWQgMCAhPT0gZG9tLnNwbGl0VGV4dCAmJiBkb20ucGFyZW50Tm9kZSAmJiAoIWRvbS5fY29tcG9uZW50IHx8IGNvbXBvbmVudFJvb3QpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvbS5ub2RlVmFsdWUgIT0gdm5vZGUpIGRvbS5ub2RlVmFsdWUgPSB2bm9kZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodm5vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChkb20pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbS5wYXJlbnROb2RlKSBkb20ucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQob3V0LCBkb20pO1xuICAgICAgICAgICAgICAgICAgICByZWNvbGxlY3ROb2RlVHJlZShkb20sICEwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQuX19wcmVhY3RhdHRyXyA9ICEwO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdm5vZGVOYW1lID0gdm5vZGUubm9kZU5hbWU7XG4gICAgICAgIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiB2bm9kZU5hbWUpIHJldHVybiBidWlsZENvbXBvbmVudEZyb21WTm9kZShkb20sIHZub2RlLCBjb250ZXh0LCBtb3VudEFsbCk7XG4gICAgICAgIGlzU3ZnTW9kZSA9ICdzdmcnID09PSB2bm9kZU5hbWUgPyAhMCA6ICdmb3JlaWduT2JqZWN0JyA9PT0gdm5vZGVOYW1lID8gITEgOiBpc1N2Z01vZGU7XG4gICAgICAgIHZub2RlTmFtZSA9IFN0cmluZyh2bm9kZU5hbWUpO1xuICAgICAgICBpZiAoIWRvbSB8fCAhaXNOYW1lZE5vZGUoZG9tLCB2bm9kZU5hbWUpKSB7XG4gICAgICAgICAgICBvdXQgPSBjcmVhdGVOb2RlKHZub2RlTmFtZSwgaXNTdmdNb2RlKTtcbiAgICAgICAgICAgIGlmIChkb20pIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZG9tLmZpcnN0Q2hpbGQpIG91dC5hcHBlbmRDaGlsZChkb20uZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbS5wYXJlbnROb2RlKSBkb20ucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQob3V0LCBkb20pO1xuICAgICAgICAgICAgICAgIHJlY29sbGVjdE5vZGVUcmVlKGRvbSwgITApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBmYyA9IG91dC5maXJzdENoaWxkLCBwcm9wcyA9IG91dC5fX3ByZWFjdGF0dHJfLCB2Y2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICAgICAgaWYgKG51bGwgPT0gcHJvcHMpIHtcbiAgICAgICAgICAgIHByb3BzID0gb3V0Ll9fcHJlYWN0YXR0cl8gPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGEgPSBvdXQuYXR0cmlidXRlcywgaSA9IGEubGVuZ3RoOyBpLS07ICkgcHJvcHNbYVtpXS5uYW1lXSA9IGFbaV0udmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoeWRyYXRpbmcgJiYgdmNoaWxkcmVuICYmIDEgPT09IHZjaGlsZHJlbi5sZW5ndGggJiYgJ3N0cmluZycgPT0gdHlwZW9mIHZjaGlsZHJlblswXSAmJiBudWxsICE9IGZjICYmIHZvaWQgMCAhPT0gZmMuc3BsaXRUZXh0ICYmIG51bGwgPT0gZmMubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIGlmIChmYy5ub2RlVmFsdWUgIT0gdmNoaWxkcmVuWzBdKSBmYy5ub2RlVmFsdWUgPSB2Y2hpbGRyZW5bMF07XG4gICAgICAgIH0gZWxzZSBpZiAodmNoaWxkcmVuICYmIHZjaGlsZHJlbi5sZW5ndGggfHwgbnVsbCAhPSBmYykgaW5uZXJEaWZmTm9kZShvdXQsIHZjaGlsZHJlbiwgY29udGV4dCwgbW91bnRBbGwsIGh5ZHJhdGluZyB8fCBudWxsICE9IHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKTtcbiAgICAgICAgZGlmZkF0dHJpYnV0ZXMob3V0LCB2bm9kZS5hdHRyaWJ1dGVzLCBwcm9wcyk7XG4gICAgICAgIGlzU3ZnTW9kZSA9IHByZXZTdmdNb2RlO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbm5lckRpZmZOb2RlKGRvbSwgdmNoaWxkcmVuLCBjb250ZXh0LCBtb3VudEFsbCwgaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgdmFyIGosIGMsIGYsIHZjaGlsZCwgY2hpbGQsIG9yaWdpbmFsQ2hpbGRyZW4gPSBkb20uY2hpbGROb2RlcywgY2hpbGRyZW4gPSBbXSwga2V5ZWQgPSB7fSwga2V5ZWRMZW4gPSAwLCBtaW4gPSAwLCBsZW4gPSBvcmlnaW5hbENoaWxkcmVuLmxlbmd0aCwgY2hpbGRyZW5MZW4gPSAwLCB2bGVuID0gdmNoaWxkcmVuID8gdmNoaWxkcmVuLmxlbmd0aCA6IDA7XG4gICAgICAgIGlmICgwICE9PSBsZW4pIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBfY2hpbGQgPSBvcmlnaW5hbENoaWxkcmVuW2ldLCBwcm9wcyA9IF9jaGlsZC5fX3ByZWFjdGF0dHJfLCBrZXkgPSB2bGVuICYmIHByb3BzID8gX2NoaWxkLl9jb21wb25lbnQgPyBfY2hpbGQuX2NvbXBvbmVudC5fX2sgOiBwcm9wcy5rZXkgOiBudWxsO1xuICAgICAgICAgICAgaWYgKG51bGwgIT0ga2V5KSB7XG4gICAgICAgICAgICAgICAga2V5ZWRMZW4rKztcbiAgICAgICAgICAgICAgICBrZXllZFtrZXldID0gX2NoaWxkO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wcyB8fCAodm9pZCAwICE9PSBfY2hpbGQuc3BsaXRUZXh0ID8gaXNIeWRyYXRpbmcgPyBfY2hpbGQubm9kZVZhbHVlLnRyaW0oKSA6ICEwIDogaXNIeWRyYXRpbmcpKSBjaGlsZHJlbltjaGlsZHJlbkxlbisrXSA9IF9jaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoMCAhPT0gdmxlbikgZm9yICh2YXIgaSA9IDA7IGkgPCB2bGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZjaGlsZCA9IHZjaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGNoaWxkID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBrZXkgPSB2Y2hpbGQua2V5O1xuICAgICAgICAgICAgaWYgKG51bGwgIT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleWVkTGVuICYmIHZvaWQgMCAhPT0ga2V5ZWRba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IGtleWVkW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGtleWVkW2tleV0gPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIGtleWVkTGVuLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghY2hpbGQgJiYgbWluIDwgY2hpbGRyZW5MZW4pIGZvciAoaiA9IG1pbjsgaiA8IGNoaWxkcmVuTGVuOyBqKyspIGlmICh2b2lkIDAgIT09IGNoaWxkcmVuW2pdICYmIGlzU2FtZU5vZGVUeXBlKGMgPSBjaGlsZHJlbltqXSwgdmNoaWxkLCBpc0h5ZHJhdGluZykpIHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IGM7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5bal0gPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKGogPT09IGNoaWxkcmVuTGVuIC0gMSkgY2hpbGRyZW5MZW4tLTtcbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gbWluKSBtaW4rKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkID0gaWRpZmYoY2hpbGQsIHZjaGlsZCwgY29udGV4dCwgbW91bnRBbGwpO1xuICAgICAgICAgICAgZiA9IG9yaWdpbmFsQ2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoY2hpbGQgJiYgY2hpbGQgIT09IGRvbSAmJiBjaGlsZCAhPT0gZikgaWYgKG51bGwgPT0gZikgZG9tLmFwcGVuZENoaWxkKGNoaWxkKTsgZWxzZSBpZiAoY2hpbGQgPT09IGYubmV4dFNpYmxpbmcpIHJlbW92ZU5vZGUoZik7IGVsc2UgZG9tLmluc2VydEJlZm9yZShjaGlsZCwgZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleWVkTGVuKSBmb3IgKHZhciBpIGluIGtleWVkKSBpZiAodm9pZCAwICE9PSBrZXllZFtpXSkgcmVjb2xsZWN0Tm9kZVRyZWUoa2V5ZWRbaV0sICExKTtcbiAgICAgICAgd2hpbGUgKG1pbiA8PSBjaGlsZHJlbkxlbikgaWYgKHZvaWQgMCAhPT0gKGNoaWxkID0gY2hpbGRyZW5bY2hpbGRyZW5MZW4tLV0pKSByZWNvbGxlY3ROb2RlVHJlZShjaGlsZCwgITEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWNvbGxlY3ROb2RlVHJlZShub2RlLCB1bm1vdW50T25seSkge1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gbm9kZS5fY29tcG9uZW50O1xuICAgICAgICBpZiAoY29tcG9uZW50KSB1bm1vdW50Q29tcG9uZW50KGNvbXBvbmVudCk7IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG51bGwgIT0gbm9kZS5fX3ByZWFjdGF0dHJfICYmIG5vZGUuX19wcmVhY3RhdHRyXy5yZWYpIG5vZGUuX19wcmVhY3RhdHRyXy5yZWYobnVsbCk7XG4gICAgICAgICAgICBpZiAoITEgPT09IHVubW91bnRPbmx5IHx8IG51bGwgPT0gbm9kZS5fX3ByZWFjdGF0dHJfKSByZW1vdmVOb2RlKG5vZGUpO1xuICAgICAgICAgICAgcmVtb3ZlQ2hpbGRyZW4obm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQ2hpbGRyZW4obm9kZSkge1xuICAgICAgICBub2RlID0gbm9kZS5sYXN0Q2hpbGQ7XG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgcmVjb2xsZWN0Tm9kZVRyZWUobm9kZSwgITApO1xuICAgICAgICAgICAgbm9kZSA9IG5leHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGlmZkF0dHJpYnV0ZXMoZG9tLCBhdHRycywgb2xkKSB7XG4gICAgICAgIHZhciBuYW1lO1xuICAgICAgICBmb3IgKG5hbWUgaW4gb2xkKSBpZiAoKCFhdHRycyB8fCBudWxsID09IGF0dHJzW25hbWVdKSAmJiBudWxsICE9IG9sZFtuYW1lXSkgc2V0QWNjZXNzb3IoZG9tLCBuYW1lLCBvbGRbbmFtZV0sIG9sZFtuYW1lXSA9IHZvaWQgMCwgaXNTdmdNb2RlKTtcbiAgICAgICAgZm9yIChuYW1lIGluIGF0dHJzKSBpZiAoISgnY2hpbGRyZW4nID09PSBuYW1lIHx8ICdpbm5lckhUTUwnID09PSBuYW1lIHx8IG5hbWUgaW4gb2xkICYmIGF0dHJzW25hbWVdID09PSAoJ3ZhbHVlJyA9PT0gbmFtZSB8fCAnY2hlY2tlZCcgPT09IG5hbWUgPyBkb21bbmFtZV0gOiBvbGRbbmFtZV0pKSkgc2V0QWNjZXNzb3IoZG9tLCBuYW1lLCBvbGRbbmFtZV0sIG9sZFtuYW1lXSA9IGF0dHJzW25hbWVdLCBpc1N2Z01vZGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb2xsZWN0Q29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgICAgICB2YXIgbmFtZSA9IGNvbXBvbmVudC5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICAoY29tcG9uZW50c1tuYW1lXSB8fCAoY29tcG9uZW50c1tuYW1lXSA9IFtdKSkucHVzaChjb21wb25lbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQoQ3RvciwgcHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGluc3QsIGxpc3QgPSBjb21wb25lbnRzW0N0b3IubmFtZV07XG4gICAgICAgIGlmIChDdG9yLnByb3RvdHlwZSAmJiBDdG9yLnByb3RvdHlwZS5yZW5kZXIpIHtcbiAgICAgICAgICAgIGluc3QgPSBuZXcgQ3Rvcihwcm9wcywgY29udGV4dCk7XG4gICAgICAgICAgICBDb21wb25lbnQuY2FsbChpbnN0LCBwcm9wcywgY29udGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnN0ID0gbmV3IENvbXBvbmVudChwcm9wcywgY29udGV4dCk7XG4gICAgICAgICAgICBpbnN0LmNvbnN0cnVjdG9yID0gQ3RvcjtcbiAgICAgICAgICAgIGluc3QucmVuZGVyID0gZG9SZW5kZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpc3QpIGZvciAodmFyIGkgPSBsaXN0Lmxlbmd0aDsgaS0tOyApIGlmIChsaXN0W2ldLmNvbnN0cnVjdG9yID09PSBDdG9yKSB7XG4gICAgICAgICAgICBpbnN0Ll9fYiA9IGxpc3RbaV0uX19iO1xuICAgICAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5zdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZG9SZW5kZXIocHJvcHMsIHN0YXRlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKHByb3BzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0Q29tcG9uZW50UHJvcHMoY29tcG9uZW50LCBwcm9wcywgb3B0cywgY29udGV4dCwgbW91bnRBbGwpIHtcbiAgICAgICAgaWYgKCFjb21wb25lbnQuX194KSB7XG4gICAgICAgICAgICBjb21wb25lbnQuX194ID0gITA7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50Ll9fciA9IHByb3BzLnJlZikgZGVsZXRlIHByb3BzLnJlZjtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQuX19rID0gcHJvcHMua2V5KSBkZWxldGUgcHJvcHMua2V5O1xuICAgICAgICAgICAgaWYgKCFjb21wb25lbnQuYmFzZSB8fCBtb3VudEFsbCkge1xuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQuY29tcG9uZW50V2lsbE1vdW50KSBjb21wb25lbnQuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbXBvbmVudC5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKSBjb21wb25lbnQuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhwcm9wcywgY29udGV4dCk7XG4gICAgICAgICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0ICE9PSBjb21wb25lbnQuY29udGV4dCkge1xuICAgICAgICAgICAgICAgIGlmICghY29tcG9uZW50Ll9fYykgY29tcG9uZW50Ll9fYyA9IGNvbXBvbmVudC5jb250ZXh0O1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY29tcG9uZW50Ll9fcCkgY29tcG9uZW50Ll9fcCA9IGNvbXBvbmVudC5wcm9wcztcbiAgICAgICAgICAgIGNvbXBvbmVudC5wcm9wcyA9IHByb3BzO1xuICAgICAgICAgICAgY29tcG9uZW50Ll9feCA9ICExO1xuICAgICAgICAgICAgaWYgKDAgIT09IG9wdHMpIGlmICgxID09PSBvcHRzIHx8ICExICE9PSBvcHRpb25zLnN5bmNDb21wb25lbnRVcGRhdGVzIHx8ICFjb21wb25lbnQuYmFzZSkgcmVuZGVyQ29tcG9uZW50KGNvbXBvbmVudCwgMSwgbW91bnRBbGwpOyBlbHNlIGVucXVldWVSZW5kZXIoY29tcG9uZW50KTtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQuX19yKSBjb21wb25lbnQuX19yKGNvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyQ29tcG9uZW50KGNvbXBvbmVudCwgb3B0cywgbW91bnRBbGwsIGlzQ2hpbGQpIHtcbiAgICAgICAgaWYgKCFjb21wb25lbnQuX194KSB7XG4gICAgICAgICAgICB2YXIgcmVuZGVyZWQsIGluc3QsIGNiYXNlLCBwcm9wcyA9IGNvbXBvbmVudC5wcm9wcywgc3RhdGUgPSBjb21wb25lbnQuc3RhdGUsIGNvbnRleHQgPSBjb21wb25lbnQuY29udGV4dCwgcHJldmlvdXNQcm9wcyA9IGNvbXBvbmVudC5fX3AgfHwgcHJvcHMsIHByZXZpb3VzU3RhdGUgPSBjb21wb25lbnQuX19zIHx8IHN0YXRlLCBwcmV2aW91c0NvbnRleHQgPSBjb21wb25lbnQuX19jIHx8IGNvbnRleHQsIGlzVXBkYXRlID0gY29tcG9uZW50LmJhc2UsIG5leHRCYXNlID0gY29tcG9uZW50Ll9fYiwgaW5pdGlhbEJhc2UgPSBpc1VwZGF0ZSB8fCBuZXh0QmFzZSwgaW5pdGlhbENoaWxkQ29tcG9uZW50ID0gY29tcG9uZW50Ll9jb21wb25lbnQsIHNraXAgPSAhMTtcbiAgICAgICAgICAgIGlmIChpc1VwZGF0ZSkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5wcm9wcyA9IHByZXZpb3VzUHJvcHM7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnN0YXRlID0gcHJldmlvdXNTdGF0ZTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuY29udGV4dCA9IHByZXZpb3VzQ29udGV4dDtcbiAgICAgICAgICAgICAgICBpZiAoMiAhPT0gb3B0cyAmJiBjb21wb25lbnQuc2hvdWxkQ29tcG9uZW50VXBkYXRlICYmICExID09PSBjb21wb25lbnQuc2hvdWxkQ29tcG9uZW50VXBkYXRlKHByb3BzLCBzdGF0ZSwgY29udGV4dCkpIHNraXAgPSAhMDsgZWxzZSBpZiAoY29tcG9uZW50LmNvbXBvbmVudFdpbGxVcGRhdGUpIGNvbXBvbmVudC5jb21wb25lbnRXaWxsVXBkYXRlKHByb3BzLCBzdGF0ZSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnByb3BzID0gcHJvcHM7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnN0YXRlID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29tcG9uZW50Ll9fcCA9IGNvbXBvbmVudC5fX3MgPSBjb21wb25lbnQuX19jID0gY29tcG9uZW50Ll9fYiA9IG51bGw7XG4gICAgICAgICAgICBjb21wb25lbnQuX19kID0gITE7XG4gICAgICAgICAgICBpZiAoIXNraXApIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlZCA9IGNvbXBvbmVudC5yZW5kZXIocHJvcHMsIHN0YXRlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50LmdldENoaWxkQ29udGV4dCkgY29udGV4dCA9IGV4dGVuZChleHRlbmQoe30sIGNvbnRleHQpLCBjb21wb25lbnQuZ2V0Q2hpbGRDb250ZXh0KCkpO1xuICAgICAgICAgICAgICAgIHZhciB0b1VubW91bnQsIGJhc2UsIGNoaWxkQ29tcG9uZW50ID0gcmVuZGVyZWQgJiYgcmVuZGVyZWQubm9kZU5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGNoaWxkQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZFByb3BzID0gZ2V0Tm9kZVByb3BzKHJlbmRlcmVkKTtcbiAgICAgICAgICAgICAgICAgICAgaW5zdCA9IGluaXRpYWxDaGlsZENvbXBvbmVudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc3QgJiYgaW5zdC5jb25zdHJ1Y3RvciA9PT0gY2hpbGRDb21wb25lbnQgJiYgY2hpbGRQcm9wcy5rZXkgPT0gaW5zdC5fX2spIHNldENvbXBvbmVudFByb3BzKGluc3QsIGNoaWxkUHJvcHMsIDEsIGNvbnRleHQsICExKTsgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1VubW91bnQgPSBpbnN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50Ll9jb21wb25lbnQgPSBpbnN0ID0gY3JlYXRlQ29tcG9uZW50KGNoaWxkQ29tcG9uZW50LCBjaGlsZFByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3QuX19iID0gaW5zdC5fX2IgfHwgbmV4dEJhc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0Ll9fdSA9IGNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldENvbXBvbmVudFByb3BzKGluc3QsIGNoaWxkUHJvcHMsIDAsIGNvbnRleHQsICExKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckNvbXBvbmVudChpbnN0LCAxLCBtb3VudEFsbCwgITApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJhc2UgPSBpbnN0LmJhc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2Jhc2UgPSBpbml0aWFsQmFzZTtcbiAgICAgICAgICAgICAgICAgICAgdG9Vbm1vdW50ID0gaW5pdGlhbENoaWxkQ29tcG9uZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9Vbm1vdW50KSBjYmFzZSA9IGNvbXBvbmVudC5fY29tcG9uZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluaXRpYWxCYXNlIHx8IDEgPT09IG9wdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYmFzZSkgY2Jhc2UuX2NvbXBvbmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlID0gZGlmZihjYmFzZSwgcmVuZGVyZWQsIGNvbnRleHQsIG1vdW50QWxsIHx8ICFpc1VwZGF0ZSwgaW5pdGlhbEJhc2UgJiYgaW5pdGlhbEJhc2UucGFyZW50Tm9kZSwgITApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbml0aWFsQmFzZSAmJiBiYXNlICE9PSBpbml0aWFsQmFzZSAmJiBpbnN0ICE9PSBpbml0aWFsQ2hpbGRDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VQYXJlbnQgPSBpbml0aWFsQmFzZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZVBhcmVudCAmJiBiYXNlICE9PSBiYXNlUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlUGFyZW50LnJlcGxhY2VDaGlsZChiYXNlLCBpbml0aWFsQmFzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRvVW5tb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxCYXNlLl9jb21wb25lbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY29sbGVjdE5vZGVUcmVlKGluaXRpYWxCYXNlLCAhMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRvVW5tb3VudCkgdW5tb3VudENvbXBvbmVudCh0b1VubW91bnQpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5iYXNlID0gYmFzZTtcbiAgICAgICAgICAgICAgICBpZiAoYmFzZSAmJiAhaXNDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50UmVmID0gY29tcG9uZW50LCB0ID0gY29tcG9uZW50O1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodCA9IHQuX191KSAoY29tcG9uZW50UmVmID0gdCkuYmFzZSA9IGJhc2U7XG4gICAgICAgICAgICAgICAgICAgIGJhc2UuX2NvbXBvbmVudCA9IGNvbXBvbmVudFJlZjtcbiAgICAgICAgICAgICAgICAgICAgYmFzZS5fY29tcG9uZW50Q29uc3RydWN0b3IgPSBjb21wb25lbnRSZWYuY29uc3RydWN0b3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1VwZGF0ZSB8fCBtb3VudEFsbCkgbW91bnRzLnVuc2hpZnQoY29tcG9uZW50KTsgZWxzZSBpZiAoIXNraXApIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50LmNvbXBvbmVudERpZFVwZGF0ZSkgY29tcG9uZW50LmNvbXBvbmVudERpZFVwZGF0ZShwcmV2aW91c1Byb3BzLCBwcmV2aW91c1N0YXRlLCBwcmV2aW91c0NvbnRleHQpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmFmdGVyVXBkYXRlKSBvcHRpb25zLmFmdGVyVXBkYXRlKGNvbXBvbmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobnVsbCAhPSBjb21wb25lbnQuX19oKSB3aGlsZSAoY29tcG9uZW50Ll9faC5sZW5ndGgpIGNvbXBvbmVudC5fX2gucG9wKCkuY2FsbChjb21wb25lbnQpO1xuICAgICAgICAgICAgaWYgKCFkaWZmTGV2ZWwgJiYgIWlzQ2hpbGQpIGZsdXNoTW91bnRzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYnVpbGRDb21wb25lbnRGcm9tVk5vZGUoZG9tLCB2bm9kZSwgY29udGV4dCwgbW91bnRBbGwpIHtcbiAgICAgICAgdmFyIGMgPSBkb20gJiYgZG9tLl9jb21wb25lbnQsIG9yaWdpbmFsQ29tcG9uZW50ID0gYywgb2xkRG9tID0gZG9tLCBpc0RpcmVjdE93bmVyID0gYyAmJiBkb20uX2NvbXBvbmVudENvbnN0cnVjdG9yID09PSB2bm9kZS5ub2RlTmFtZSwgaXNPd25lciA9IGlzRGlyZWN0T3duZXIsIHByb3BzID0gZ2V0Tm9kZVByb3BzKHZub2RlKTtcbiAgICAgICAgd2hpbGUgKGMgJiYgIWlzT3duZXIgJiYgKGMgPSBjLl9fdSkpIGlzT3duZXIgPSBjLmNvbnN0cnVjdG9yID09PSB2bm9kZS5ub2RlTmFtZTtcbiAgICAgICAgaWYgKGMgJiYgaXNPd25lciAmJiAoIW1vdW50QWxsIHx8IGMuX2NvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIHNldENvbXBvbmVudFByb3BzKGMsIHByb3BzLCAzLCBjb250ZXh0LCBtb3VudEFsbCk7XG4gICAgICAgICAgICBkb20gPSBjLmJhc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWxDb21wb25lbnQgJiYgIWlzRGlyZWN0T3duZXIpIHtcbiAgICAgICAgICAgICAgICB1bm1vdW50Q29tcG9uZW50KG9yaWdpbmFsQ29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICBkb20gPSBvbGREb20gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYyA9IGNyZWF0ZUNvbXBvbmVudCh2bm9kZS5ub2RlTmFtZSwgcHJvcHMsIGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKGRvbSAmJiAhYy5fX2IpIHtcbiAgICAgICAgICAgICAgICBjLl9fYiA9IGRvbTtcbiAgICAgICAgICAgICAgICBvbGREb20gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0Q29tcG9uZW50UHJvcHMoYywgcHJvcHMsIDEsIGNvbnRleHQsIG1vdW50QWxsKTtcbiAgICAgICAgICAgIGRvbSA9IGMuYmFzZTtcbiAgICAgICAgICAgIGlmIChvbGREb20gJiYgZG9tICE9PSBvbGREb20pIHtcbiAgICAgICAgICAgICAgICBvbGREb20uX2NvbXBvbmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmVjb2xsZWN0Tm9kZVRyZWUob2xkRG9tLCAhMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvbTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5tb3VudENvbXBvbmVudChjb21wb25lbnQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYmVmb3JlVW5tb3VudCkgb3B0aW9ucy5iZWZvcmVVbm1vdW50KGNvbXBvbmVudCk7XG4gICAgICAgIHZhciBiYXNlID0gY29tcG9uZW50LmJhc2U7XG4gICAgICAgIGNvbXBvbmVudC5fX3ggPSAhMDtcbiAgICAgICAgaWYgKGNvbXBvbmVudC5jb21wb25lbnRXaWxsVW5tb3VudCkgY29tcG9uZW50LmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG4gICAgICAgIGNvbXBvbmVudC5iYXNlID0gbnVsbDtcbiAgICAgICAgdmFyIGlubmVyID0gY29tcG9uZW50Ll9jb21wb25lbnQ7XG4gICAgICAgIGlmIChpbm5lcikgdW5tb3VudENvbXBvbmVudChpbm5lcik7IGVsc2UgaWYgKGJhc2UpIHtcbiAgICAgICAgICAgIGlmIChiYXNlLl9fcHJlYWN0YXR0cl8gJiYgYmFzZS5fX3ByZWFjdGF0dHJfLnJlZikgYmFzZS5fX3ByZWFjdGF0dHJfLnJlZihudWxsKTtcbiAgICAgICAgICAgIGNvbXBvbmVudC5fX2IgPSBiYXNlO1xuICAgICAgICAgICAgcmVtb3ZlTm9kZShiYXNlKTtcbiAgICAgICAgICAgIGNvbGxlY3RDb21wb25lbnQoY29tcG9uZW50KTtcbiAgICAgICAgICAgIHJlbW92ZUNoaWxkcmVuKGJhc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wb25lbnQuX19yKSBjb21wb25lbnQuX19yKG51bGwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBDb21wb25lbnQocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fX2QgPSAhMDtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5zdGF0ZSB8fCB7fTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyKHZub2RlLCBwYXJlbnQsIG1lcmdlKSB7XG4gICAgICAgIHJldHVybiBkaWZmKG1lcmdlLCB2bm9kZSwge30sICExLCBwYXJlbnQsICExKTtcbiAgICB9XG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICB2YXIgRU1QVFlfQ0hJTERSRU4gPSBbXTtcbiAgICB2YXIgZGVmZXIgPSAnZnVuY3Rpb24nID09IHR5cGVvZiBQcm9taXNlID8gUHJvbWlzZS5yZXNvbHZlKCkudGhlbi5iaW5kKFByb21pc2UucmVzb2x2ZSgpKSA6IHNldFRpbWVvdXQ7XG4gICAgdmFyIElTX05PTl9ESU1FTlNJT05BTCA9IC9hY2l0fGV4KD86c3xnfG58cHwkKXxycGh8b3dzfG1uY3xudHd8aW5lW2NoXXx6b298Xm9yZC9pO1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHZhciBtb3VudHMgPSBbXTtcbiAgICB2YXIgZGlmZkxldmVsID0gMDtcbiAgICB2YXIgaXNTdmdNb2RlID0gITE7XG4gICAgdmFyIGh5ZHJhdGluZyA9ICExO1xuICAgIHZhciBjb21wb25lbnRzID0ge307XG4gICAgZXh0ZW5kKENvbXBvbmVudC5wcm90b3R5cGUsIHtcbiAgICAgICAgc2V0U3RhdGU6IGZ1bmN0aW9uKHN0YXRlLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIHMgPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9fcykgdGhpcy5fX3MgPSBleHRlbmQoe30sIHMpO1xuICAgICAgICAgICAgZXh0ZW5kKHMsICdmdW5jdGlvbicgPT0gdHlwZW9mIHN0YXRlID8gc3RhdGUocywgdGhpcy5wcm9wcykgOiBzdGF0ZSk7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spICh0aGlzLl9faCA9IHRoaXMuX19oIHx8IFtdKS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGVucXVldWVSZW5kZXIodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIGZvcmNlVXBkYXRlOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSAodGhpcy5fX2ggPSB0aGlzLl9faCB8fCBbXSkucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICByZW5kZXJDb21wb25lbnQodGhpcywgMik7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7fVxuICAgIH0pO1xuICAgIHZhciBwcmVhY3QgPSB7XG4gICAgICAgIGg6IGgsXG4gICAgICAgIGNyZWF0ZUVsZW1lbnQ6IGgsXG4gICAgICAgIGNsb25lRWxlbWVudDogY2xvbmVFbGVtZW50LFxuICAgICAgICBDb21wb25lbnQ6IENvbXBvbmVudCxcbiAgICAgICAgcmVuZGVyOiByZW5kZXIsXG4gICAgICAgIHJlcmVuZGVyOiByZXJlbmRlcixcbiAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgIH07XG4gICAgaWYgKCd1bmRlZmluZWQnICE9IHR5cGVvZiBtb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gcHJlYWN0OyBlbHNlIHNlbGYucHJlYWN0ID0gcHJlYWN0O1xufSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJlYWN0LmpzLm1hcCIsIi8qIVxuICBDb3B5cmlnaHQgKGMpIDIwMTcgSmVkIFdhdHNvbi5cbiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCBzZWVcbiAgaHR0cDovL2plZHdhdHNvbi5naXRodWIuaW8vY2xhc3NuYW1lc1xuKi9cbi8qIGdsb2JhbCBkZWZpbmUgKi9cblxuKGZ1bmN0aW9uICgpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBoYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuXHRmdW5jdGlvbiBjbGFzc05hbWVzICgpIHtcblx0XHR2YXIgY2xhc3NlcyA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRpZiAoIWFyZykgY29udGludWU7XG5cblx0XHRcdHZhciBhcmdUeXBlID0gdHlwZW9mIGFyZztcblxuXHRcdFx0aWYgKGFyZ1R5cGUgPT09ICdzdHJpbmcnIHx8IGFyZ1R5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdGNsYXNzZXMucHVzaChhcmcpO1xuXHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykgJiYgYXJnLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgaW5uZXIgPSBjbGFzc05hbWVzLmFwcGx5KG51bGwsIGFyZyk7XG5cdFx0XHRcdGlmIChpbm5lcikge1xuXHRcdFx0XHRcdGNsYXNzZXMucHVzaChpbm5lcik7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIGFyZykge1xuXHRcdFx0XHRcdGlmIChoYXNPd24uY2FsbChhcmcsIGtleSkgJiYgYXJnW2tleV0pIHtcblx0XHRcdFx0XHRcdGNsYXNzZXMucHVzaChrZXkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBjbGFzc2VzLmpvaW4oJyAnKTtcblx0fVxuXG5cdGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRcdGNsYXNzTmFtZXMuZGVmYXVsdCA9IGNsYXNzTmFtZXM7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBjbGFzc05hbWVzO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyByZWdpc3RlciBhcyAnY2xhc3NuYW1lcycsIGNvbnNpc3RlbnQgd2l0aCBucG0gcGFja2FnZSBuYW1lXG5cdFx0ZGVmaW5lKCdjbGFzc25hbWVzJywgW10sIGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBjbGFzc05hbWVzO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdHdpbmRvdy5jbGFzc05hbWVzID0gY2xhc3NOYW1lcztcblx0fVxufSgpKTtcbiIsImNvbnN0IGRlZmluZWQgPSByZXF1aXJlKCdkZWZpbmVkJyk7XG5jb25zdCB7IGV4cGFuZDJEIH0gPSByZXF1aXJlKCcuL21hdGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICBjb25zdCBwYWludCA9IChvcHQgPSB7fSkgPT4ge1xuICAgIGxldCBmaWxsID0gb3B0LmZpbGw7XG4gICAgbGV0IHN0cm9rZSA9IG9wdC5zdHJva2U7XG4gICAgY29uc3QgZGVmYXVsdENvbG9yID0gJ2JsYWNrJztcbiAgICBjb25zdCBhbHBoYSA9IGRlZmluZWQob3B0LmFscGhhLCAxKTtcblxuICAgIC8vIERlZmF1bHQgdG8gZmlsbC1vbmx5XG4gICAgaWYgKG9wdC5maWxsID09IG51bGwgJiYgb3B0LnN0cm9rZSA9PSBudWxsKSBmaWxsID0gdHJ1ZTtcblxuICAgIGlmIChmaWxsKSB7XG4gICAgICBjb25zdCBmaWxsQWxwaGEgPSBkZWZpbmVkKG9wdC5maWxsQWxwaGEsIDEpO1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSB0eXBlb2YgZmlsbCA9PT0gJ2Jvb2xlYW4nID8gZGVmYXVsdENvbG9yIDogZmlsbDtcbiAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBhbHBoYSAqIGZpbGxBbHBoYTtcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIH1cbiAgICBjb25zdCBsaW5lV2lkdGggPSBkZWZpbmVkKG9wdC5saW5lV2lkdGgsIDEpO1xuICAgIGlmIChzdHJva2UgJiYgbGluZVdpZHRoID4gMCkge1xuICAgICAgY29uc3Qgc3Ryb2tlQWxwaGEgPSBkZWZpbmVkKG9wdC5zdHJva2VBbHBoYSwgMSk7XG4gICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gdHlwZW9mIHN0cm9rZSA9PT0gJ2Jvb2xlYW4nID8gZGVmYXVsdENvbG9yIDogc3Ryb2tlO1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICBjb250ZXh0LmxpbmVDYXAgPSBvcHQubGluZUNhcCB8fCAnYnV0dCc7XG4gICAgICBjb250ZXh0LmxpbmVKb2luID0gb3B0LmxpbmVKb2luIHx8ICdtaXRlcic7XG4gICAgICBjb250ZXh0Lm1pdGVyTGltaXQgPSBkZWZpbmVkKG9wdC5taXRlckxpbWl0LCAxMCk7XG4gICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gYWxwaGEgKiBzdHJva2VBbHBoYTtcbiAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGNpcmNsZSA9IChvcHQgPSB7fSkgPT4ge1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29uc3QgcmFkaXVzID0gTWF0aC5tYXgoMCwgZGVmaW5lZChvcHQucmFkaXVzLCAxKSk7XG4gICAgY29uc3QgcG9zaXRpb24gPSBleHBhbmQyRChvcHQucG9zaXRpb24pO1xuICAgIGNvbnN0IGFyY1N0YXJ0ID0gZGVmaW5lZChvcHQuYXJjU3RhcnQsIDApO1xuICAgIGNvbnN0IGFyY0VuZCA9IGRlZmluZWQob3B0LmFyY0VuZCwgTWF0aC5QSSAqIDIpO1xuICAgIGNvbnRleHQuYXJjKHBvc2l0aW9uWzBdLCBwb3NpdGlvblsxXSwgcmFkaXVzLCBhcmNTdGFydCwgYXJjRW5kLCBmYWxzZSk7XG4gICAgcGFpbnQob3B0KTtcbiAgfTtcblxuICBjb25zdCByZWN0ID0gKG9wdCA9IHt9KSA9PiB7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb25zdCBwb3NpdGlvbiA9IGV4cGFuZDJEKG9wdC5wb3NpdGlvbik7XG4gICAgY29uc3Qgd2lkdGggPSBkZWZpbmVkKG9wdC53aWR0aCwgMSk7XG4gICAgY29uc3QgaGVpZ2h0ID0gZGVmaW5lZChvcHQuaGVpZ2h0LCAxKTtcbiAgICBjb250ZXh0LnJlY3QocG9zaXRpb25bMF0sIHBvc2l0aW9uWzFdLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBwYWludChvcHQpO1xuICB9O1xuXG4gIGNvbnN0IF9saW5lID0gKHBhdGgsIG9wdCA9IHt9LCBkZWZhdWx0VG9TdHJva2UgPSBmYWxzZSkgPT4ge1xuICAgIG9wdCA9IE9iamVjdC5hc3NpZ24oe30sIG9wdCk7XG5cbiAgICBpZiAoZGVmYXVsdFRvU3Ryb2tlKSB7XG4gICAgICBpZiAob3B0LmZpbGwgPT0gbnVsbCAmJiBvcHQuc3Ryb2tlID09IG51bGwpIG9wdC5zdHJva2UgPSB0cnVlO1xuICAgIH1cblxuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgcGF0aC5mb3JFYWNoKHBvaW50ID0+IGNvbnRleHQubGluZVRvKHBvaW50WzBdLCBwb2ludFsxXSkpO1xuICAgIGlmIChvcHQuY2xvc2VkKSBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHBhaW50KG9wdCk7XG4gIH07XG5cbiAgY29uc3QgcG9seWxpbmUgPSAocGF0aCwgb3B0ID0ge30pID0+IF9saW5lKHBhdGgsIG9wdCwgdHJ1ZSk7XG4gIGNvbnN0IHNoYXBlID0gKHNoYXBlLCBvcHQgPSB7fSkgPT4gX2xpbmUoc2hhcGUsIG9wdCwgZmFsc2UpO1xuXG4gIGNvbnN0IHBvbHlsaW5lcyA9IChsaW5lcywgb3B0ID0ge30pID0+IHtcbiAgICBsaW5lcy5mb3JFYWNoKHBhdGggPT4gcG9seWxpbmUocGF0aCwgb3B0KSk7XG4gIH07XG5cbiAgY29uc3QgY2xlYXIgPSAob3B0ID0ge30pID0+IHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IGV4cGFuZDJEKG9wdC5wb3NpdGlvbik7XG4gICAgY29uc3Qgd2lkdGggPSBkZWZpbmVkKG9wdC53aWR0aCwgY29udGV4dC5jYW52YXMud2lkdGgpO1xuICAgIGNvbnN0IGhlaWdodCA9IGRlZmluZWQob3B0LmhlaWdodCwgY29udGV4dC5jYW52YXMuaGVpZ2h0KTtcblxuICAgIC8vIGNsZWFyIGZpcnN0IGluIGNhc2Ugd2UgaGF2ZSBhIHRyYW5zbHVjZW50IGZpbGxcbiAgICBjb250ZXh0LmNsZWFyUmVjdChwb3NpdGlvblswXSwgcG9zaXRpb25bMV0sIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgLy8gbm93IGFsbG93IHVzZXIgdG8gZmlsbFxuICAgIGlmIChvcHQuZmlsbCkge1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQucmVjdChwb3NpdGlvblswXSwgcG9zaXRpb25bMV0sIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgcGFpbnQob3B0KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBjbGVhcixcbiAgICBwYWludCxcbiAgICByZWN0LFxuICAgIGNpcmNsZSxcbiAgICBwb2x5bGluZSxcbiAgICBwb2x5bGluZXMsXG4gICAgc2hhcGVcbiAgfTtcbn07XG4iXX0=
